{"version":3,"sources":["axon.js"],"names":["Axon","DOM_EVENT_TIMEOUT","DOM_EVENT_MODEL","DOM_ATTR_PREFIX","DOM_ATTR_HIDDEN","DOM_ATTR_VALUE","DOM_ATTR_TEXT","DOM_ATTR_HTML","LIB_STRING_QUOTES","getDirectives","node","attrArr","Array","from","attributes","result","forEach","attr","name","substr","length","splitName","replace","split","push","key","opt","val","value","directiveIgnoreBoth","retrieveMethod","instance","expression","expressionSplit","methodName","methodArgs","filter","item","map","arg","evaluateExpression","methodFn","$methods","fn","args","Error","isDefined","retrieveProp","splitExpression","reference","container","$data","prop","propPath","index","isNaN","Number","includes","method","apply","directiveIfRender","directive","propValue","Boolean","removeAttribute","setAttribute","debounce","wait","immediate","timeout","context","this","arguments","callNow","later","clearTimeout","setTimeout","getNodeValueType","bindEvent","eventType","eventFn","eventArgs","debouncedFn","nodeValueType","eventFnWrapper","event","target","addEventListener","directiveOnInit","targetMethod","directiveModelInit","targetProp","currentValue","newValue","$render","directiveModelRender","directiveBindRender","directives","ignore","init","render","if","on","model","bind","execDirectives","domMap","execMode","recurseMap","mapNode","nodeChildren","children","nodeDirectives","directiveRef","directiveRefFn","directiveResult","child","getDomMap","entry","recurseNodes","childElementCount","childArr","childNode","_this","$cache","$context","console","log","config","document","querySelector","data","methods","$init","prototype","constructor"],"mappings":"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","file":"axon.min.js","sourcesContent":["/**\n * Axon v0.13.0\n * Author: Felix Rilling\n * Repository: git+https://github.com/FelixRilling/axonjs.git\n */\n\nvar Axon = (function () {\n'use strict';\n\nvar DOM_EVENT_TIMEOUT = 20; //event timeout in ms\nvar DOM_EVENT_MODEL = \"input\";\n\nvar DOM_ATTR_PREFIX = \"x-\";\nvar DOM_ATTR_HIDDEN = \"hidden\";\nvar DOM_ATTR_VALUE = \"value\";\nvar DOM_ATTR_TEXT = \"textContent\";\nvar DOM_ATTR_HTML = \"innerHTML\";\n\nvar LIB_STRING_QUOTES = [\"'\", \"\\\"\", \"`\"];\n\nvar getDirectives = function getDirectives(node) {\n    var attrArr = Array.from(node.attributes);\n    var result = [];\n\n    attrArr.forEach(function (attr) {\n        //If is Axon attribute\n        if (attr.name.substr(0, DOM_ATTR_PREFIX.length) === DOM_ATTR_PREFIX) {\n            var splitName = attr.name.replace(DOM_ATTR_PREFIX, \"\").split(\":\");\n\n            result.push({\n                key: splitName[0],\n                opt: splitName[1] || false,\n                val: attr.value\n            });\n        }\n    });\n\n    return result;\n};\n\nvar directiveIgnoreBoth = function directiveIgnoreBoth() {\n    return false;\n};\n\nvar retrieveMethod = function retrieveMethod(instance, expression) {\n    var expressionSplit = expression.substr(0, expression.length - 1).split(\"(\");\n    var methodName = expressionSplit[0];\n    var methodArgs = expressionSplit[1].split(\",\").filter(function (item) {\n        return item !== \"\";\n    }).map(function (arg) {\n        return evaluateExpression(instance, arg);\n    });\n    var methodFn = instance.$methods[methodName];\n\n    if (typeof methodFn === \"function\") {\n        return {\n            fn: methodFn,\n            args: methodArgs\n        };\n    } else {\n        throw new Error(\"Method not found: '\" + expression + \"'\");\n    }\n};\n\nvar isDefined = function isDefined(val) {\n    return typeof val !== \"undefined\";\n};\n\nvar retrieveProp = function retrieveProp(instance, expression) {\n    var splitExpression = expression.split(\".\");\n    var result = {\n        val: null,\n        reference: null\n    };\n    var container = instance.$data;\n    var prop = void 0;\n\n    splitExpression.forEach(function (propPath, index) {\n        prop = container[propPath];\n\n        if (isDefined(\"undefined\")) {\n\n            if (index < splitExpression.length - 1) {\n                container = prop;\n            } else {\n                result.val = prop;\n                result.reference = container;\n            }\n        } else {\n            throw new Error(\"Property not found: '\" + expression + \"'\");\n        }\n    });\n\n    return result;\n};\n\nvar evaluateExpression = function evaluateExpression(instance, expression) {\n    if (!isNaN(Number(expression))) {\n        //expression is a Number\n        return Number(expression);\n    } else if (LIB_STRING_QUOTES.includes(expression.substr(0, 1))) {\n        //expression is a String\n        return expression.substr(1, expression.length - 2);\n    } else if (expression.substr(expression.length - 1) === \")\") {\n        //expression is a Method\n        var method = retrieveMethod(instance, expression);\n\n        return method.fn.apply(instance, method.args);\n    } else {\n        //expression is a Property\n        return retrieveProp(instance, expression).val;\n    }\n};\n\nvar directiveIfRender = function directiveIfRender(instance, node, directive) {\n    var propValue = evaluateExpression(instance, directive.val);\n    var result = Boolean(propValue);\n\n    if (result) {\n        node.removeAttribute(DOM_ATTR_HIDDEN);\n    } else {\n        node.setAttribute(DOM_ATTR_HIDDEN, DOM_ATTR_HIDDEN);\n    }\n\n    return result;\n};\n\nvar debounce = function debounce(fn, wait, immediate) {\n    var timeout = void 0;\n\n    return function () {\n        var context = this;\n        var args = Array.from(arguments);\n        var callNow = immediate && !timeout;\n        var later = function later() {\n            timeout = null;\n            if (!immediate) {\n                fn.apply(context, args);\n            }\n        };\n\n        clearTimeout(timeout);\n        timeout = setTimeout(later, wait);\n        if (callNow) {\n            fn.apply(context, args);\n        }\n    };\n};\n\nvar getNodeValueType = function getNodeValueType(node) {\n    if (isDefined(node[DOM_ATTR_VALUE])) {\n        return DOM_ATTR_VALUE;\n    } else if (isDefined(node[DOM_ATTR_TEXT])) {\n        return DOM_ATTR_TEXT;\n    } else {\n        return DOM_ATTR_HTML;\n    }\n};\n\nvar bindEvent = function bindEvent(node, eventType, eventFn, eventArgs, instance) {\n    var debouncedFn = debounce(eventFn, DOM_EVENT_TIMEOUT);\n    var nodeValueType = getNodeValueType(node);\n\n    var eventFnWrapper = function eventFnWrapper(event) {\n        var target = event.target;\n        var args = Array.from(eventArgs);\n\n        args.push(target[nodeValueType], target, event);\n\n        return debouncedFn.apply(instance, args);\n    };\n\n    return node.addEventListener(eventType, eventFnWrapper, false);\n};\n\nvar directiveOnInit = function directiveOnInit(instance, node, directive) {\n    var targetMethod = retrieveMethod(instance, directive.val);\n\n    bindEvent(node, directive.opt, targetMethod.fn, targetMethod.args, instance);\n\n    return true;\n};\n\nvar directiveModelInit = function directiveModelInit(instance, node, directive) {\n    var targetProp = retrieveProp(instance, directive.val);\n    var eventFn = function eventFn(currentValue, newValue) {\n        targetProp.reference[directive.val] = newValue;\n\n        setTimeout(function () {\n            instance.$render();\n        }, DOM_EVENT_TIMEOUT);\n    };\n\n    bindEvent(node, DOM_EVENT_MODEL, eventFn, [targetProp.val], instance);\n\n    return true;\n};\n\nvar directiveModelRender = function directiveModelRender(instance, node, directive) {\n    var nodeValueType = getNodeValueType(node);\n    var propValue = retrieveProp(instance, directive.val);\n\n    node[nodeValueType] = propValue.val;\n\n    return true;\n};\n\nvar directiveBindRender = function directiveBindRender(instance, node, directive) {\n    var propValue = evaluateExpression(instance, directive.val);\n\n    node.setAttribute(directive.opt, propValue);\n\n    return true;\n};\n\nvar directives = {\n    ignore: {\n        init: directiveIgnoreBoth, //Init function\n        render: directiveIgnoreBoth //Render function\n    },\n    if: {\n        render: directiveIfRender\n    },\n    on: {\n        init: directiveOnInit\n    },\n    model: {\n        init: directiveModelInit,\n        render: directiveModelRender\n    },\n    bind: {\n        render: directiveBindRender\n    }\n};\n\nvar execDirectives = function execDirectives(instance, domMap, execMode) {\n    var recurseMap = function recurseMap(mapNode) {\n        var nodeChildren = mapNode.children;\n        var nodeDirectives = mapNode.directives;\n        var result = true;\n\n        //Exec on node\n        if (nodeDirectives.length) {\n            //Only exec if directives on domNode\n            mapNode.directives.forEach(function (directive) {\n                var directiveRef = directives[directive.key];\n\n                if (directiveRef) {\n                    //Only exec if directive exists\n                    var directiveRefFn = directiveRef[execMode];\n\n                    if (directiveRefFn) {\n                        //Only exec if directive has fn for current execMode\n                        var directiveResult = directiveRefFn(instance, mapNode.node, directive);\n\n                        if (!directiveResult) {\n                            //Stop crawling on directive return 'false'\n                            result = false;\n                        }\n                    }\n                }\n            });\n        }\n\n        //Crawl children\n        if (result && nodeChildren.length) {\n            nodeChildren.forEach(function (child) {\n                recurseMap(child);\n            });\n        }\n    };\n\n    recurseMap(domMap);\n};\n\nvar getDomMap = function getDomMap(entry, fn) {\n    var result = {};\n    var recurseNodes = function recurseNodes(node, container) {\n        container.node = node;\n        container.children = [];\n        fn(container, node);\n\n        if (node.childElementCount) {\n            var childArr = Array.from(node.children);\n\n            childArr.forEach(function (childNode, index) {\n                container.children[index] = {};\n\n                recurseNodes(childNode, container.children[index]);\n            });\n        }\n    };\n\n    recurseNodes(entry, result);\n\n    return result;\n};\n\nvar init = function init() {\n    var _this = this;\n\n    _this.$cache = getDomMap(_this.$context, function (container, node) {\n        //Cache all nodes & directives in the context\n        var directives = getDirectives(node);\n\n        container.directives = directives;\n    });\n\n    execDirectives(_this, _this.$cache, \"init\");\n    console.log(\"CALLED $init\");\n};\n\nvar render = function render() {\n    var _this = this;\n\n    execDirectives(_this, _this.$cache, \"render\");\n    console.log(\"CALLED $render\");\n};\n\n/**\n * Basic Axon Constructor\n *\n * @constructor\n * @param {String} id To identify the instance\n * @returns {Object} Returns Axon instance\n */\nvar Axon = function Axon(config) {\n    var _this = this;\n\n    _this.$context = document.querySelector(config.context);\n    _this.$data = config.data;\n    _this.$methods = config.methods;\n    _this.$cache = {};\n\n    _this.$init();\n    _this.$render();\n};\n\n/**\n * Expose Axon methods\n */\nAxon.prototype = {\n    $init: init,\n    $render: render,\n    constructor: Axon\n};\n\nreturn Axon;\n\n}());\n\n//# sourceMappingURL=axon.js.map\n"]}