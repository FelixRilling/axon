{"version":3,"sources":["axon.js"],"names":["Axon","eachNode","NodeList","fn","l","length","i","eachObject","object","keys","Object","currentKey","replaceFrom","string","find","replace","index","substr","extend","type","cf","_this","this","name","deps","provider","constructModule","_module","list","constructorFunction","dependencies","result","forEach","item","dependency","push","rdy","recurseDependencies","chev","get","Error","initialize","init","entry","set","access","service","serviceFn","apply","concat","Array","from","arguments","factory","unshift","Function","prototype","bind","Chevron","Map","_window","window","_document","document","_domNameSpace","_expressionRegex","constructQuery","data","val","queryDirective","context","querySelectorAll","readDirective","element","attributes","value","text","onBind","ctrl","getTextNodes","node","all","firstChild","nextSibling","nodeType","parentNode","nodeName","nodes","match","exec","textContent","lastIndex","parent","onDigest","expressions","digest","iteratePlugins","pluginData","plugin","key","active","directives","$directives","$context","$expressions","domList","dom","eventFn","ev","addEventListener","model","modelEvent","setTimeout","content","modelFor","console","log","elements","bindDirectives","directive","bindExpressions","expressions$$1","controllerFn","bundle","id","cv","methods","method"],"mappings":"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","file":"axon.min.js","sourcesContent":["/**\n * Axon v0.3.0\n * Author: Felix Rilling\n * Repository: git+https://github.com/FelixRilling/axonjs.git\n */\n\nvar Axon = (function () {\n'use strict';\n\n/**\r\n * Adds a new module type to the Chevron instance\r\n * @param {String} type The name of the type\r\n * @param {Function} cf Constructor function to init the module with\r\n * @returns {Object} Chevron instance\r\n */\n\nvar extend = function extend(type, cf) {\n    var _this = this;\n\n    //Add customType method to container\n    _this[type] = function (name, deps, fn) {\n        return _this.provider(type, //static\n        cf, //static\n        name, //dynamic\n        deps, //dynamic\n        fn //dynamic\n        );\n    };\n\n    return _this;\n};\n\n/**\r\n * Collects dependencies and initializes module\r\n * @private\r\n * @param {Object} _module The module to check\r\n * @param {Object} list The list of dependencies\r\n * @param {Function} cf The Constructor function\r\n * @returns {Object} Initialized _module\r\n */\n\nvar constructModule = function constructModule(_module, list, constructorFunction) {\n    var dependencies = [];\n    var result = void 0;\n\n    //Collect an ordered Array of dependencies\n    _module.deps.forEach(function (item) {\n        var dependency = list[item];\n\n        //If the dependency name is found in the list of deps, add it\n        if (dependency) {\n            dependencies.push(dependency.fn);\n        }\n    });\n\n    //Call Constructor fn with _module/deps\n    result = constructorFunction(_module, dependencies);\n    result.rdy = true;\n\n    return result;\n};\n\n/**\r\n * Loops trough dependencies, recurse if new dependencies has dependencies itself; then execute fn.\r\n * @private\r\n * @param {Object} chev The chevron container\r\n * @param {Array} _module The module to recurse\r\n * @param {Function} fn The function run over each dependency\r\n */\n\nvar recurseDependencies = function recurseDependencies(chev, _module, fn) {\n    _module.deps.forEach(function (name) {\n        var dependency = chev.get(name);\n\n        if (dependency) {\n            //recurse over sub-deps\n            recurseDependencies(chev, dependency, fn);\n            //run fn\n            fn(dependency);\n        } else {\n            //if the dependency is not found, throw error with name\n            throw new Error(_module.name + \" is missing dep '\" + name + \"'\");\n        }\n    });\n};\n\n/**\r\n * Inits module and all dependencies\n * @private\r\n * @param {Object} chev The chevron container\r\n * @param {Object} _module The module to prepare\r\n * @param {Function} cf The constructor function\r\n * @returns {Object} Initialized module\r\n */\nvar initialize = function initialize(chev, _module, constructorFunction) {\n    var list = {};\n\n    //Recurse trough _module deps\n    recurseDependencies(chev, _module,\n    //run this over every dependency to add it to the dependencyList\n    function (dependency) {\n        //make sure if dependency is initialized, then add\n        list[dependency.name] = dependency.rdy ? dependency : dependency.init();\n    });\n\n    return constructModule(_module, list, constructorFunction);\n};\n\n/**\r\n * Adds a new module to the container\r\n * @param {String} type The type of the module. ex: \"factory\"\r\n * @param {Function} cf The constructor function of the module\r\n * @param {String} name The name to register the module under. ex: \"myFactory\"\r\n * @param {Array} deps Array of dependenciy names\r\n * @param {Function} fn Content of the module\r\n * @returns {Object} Chevron instance\r\n */\nvar provider = function provider(type, constructorFunction, name, deps, fn) {\n    var _this = this;\n    var entry = {\n        type: type, //Type of the module\n        name: name, //Name of the module\n        deps: deps, //Array of dependencies\n        fn: fn, //Module content function\n        rdy: false, //If the module is ready to access\n        init: function init() {\n            return initialize(_this.chev, entry, constructorFunction); //init the module\n        }\n    };\n\n    //Saves entry to chev container\n    _this.chev.set(name, entry);\n\n    return _this;\n};\n\n/**\r\n * Access module with dependencies bound\r\n * @param {String} name The name of the module to access\r\n * @returns {Mixed} Initialized Object content\r\n */\n\nvar access = function access(name) {\n  return this.chev.get(name).init().fn;\n};\n\n/**\r\n * Constructor function for the service type\r\n * @private\r\n * @param {Object} _module The module object\n * @param {Array} dependencies Array of dependency contents\r\n * @returns {Mixed} Initialized _module\n */\n\nvar service = function service(_module, dependencies) {\n    //Dereference fn to avoid unwanted recursion\n    var serviceFn = _module.fn;\n\n    _module.fn = function () {\n        //Chevron service function wrapper\n        //return function with args injected\n        return serviceFn.apply(null, dependencies.concat(Array.from(arguments)));\n    };\n\n    return _module;\n};\n\n/**\r\n * Constructor function for the factory type\r\n * @private\r\n * @param {Object} _module The module object\n * @param {Array} dependencies Array of dependency contents\r\n * @returns {Mixed} Initialized module\n */\n\nvar factory = function factory(_module, dependencies) {\n    //First value gets ignored by calling 'new' like this, so we need to fill it with something\n    dependencies.unshift(0);\n\n    //Apply into new constructor by binding applying the bind method.\n    //@see: {@link http://stackoverflow.com/questions/1606797/use-of-apply-with-new-operator-is-this-possible }\n    _module.fn = new (Function.prototype.bind.apply(_module.fn, dependencies))();\n\n    return _module;\n};\n\n/**\r\n * Chevron Constructor\r\n * @constructor\r\n * @returns {Object} Chevron instance\r\n */\nvar Chevron = function Chevron() {\n    var _this = this;\n\n    //Instance container\n    _this.chev = new Map();\n\n    //Init default types\n    _this.extend(\"service\", service);\n    _this.extend(\"factory\", factory);\n};\n\n/**\r\n * Expose Chevron methods\r\n */\nChevron.prototype = {\n    extend: extend, //Creates a new module type\n    provider: provider, //Adds a new custom module to the container\n    access: access //Returns initialized module\n};\n\n/**\n * Store constants\n */\n\nvar _window = window;\nvar _document = _window.document;\nvar _domNameSpace = \"xn\";\nvar _expressionRegex = /{{(.+)}}/g;\n\n/**\n * Creates querySelector string\n *\n * @private\n * @param {String} data The data id\n * @param {String} val The data value\n * @return {String} Returns Query\n */\nvar constructQuery = function (data, val) {\n    if (!val || val === \"*\") {\n        return \"[\" + _domNameSpace + \"-\" + data + \"]\";\n    } else {\n        return \"[\" + _domNameSpace + \"-\" + data + \"='\" + val + \"']\";\n    }\n};\n\n/**\n * Query multiple from DOM\n *\n * @private\n * @param {String} data The data id\n * @param {String} val The data value\n * @param {Node} context optional, query context\n * @return {NodeList} Returns NodeList\n */\nvar queryDirective = function (data, val, context) {\n    return (context ? context : _document).querySelectorAll(constructQuery(data, val));\n};\n\n/**\n * Read Data from element\n *\n * @private\n * @param {Node} element The Element to read\n * @param {String} data The data attr to read\n * @return {String} Returns value\n */\nvar readDirective = function (element, data) {\n    return element.attributes[_domNameSpace + \"-\" + data].value;\n};\n\n/**\n * Misc Utility functions\n */\n\n/**\n * iterate over NoddeList\n *\n * @private\n * @param {NodeList} NodeList The Elements to bind\n * @param {Function} fn The Function to call\n * @returns void\n */\n\nfunction eachNode(NodeList, fn) {\n    var l = NodeList.length;\n    var i = 0;\n\n    while (i < l) {\n        fn(NodeList[i], i);\n        i++;\n    }\n}\n/**\n * Iterate object\n *\n * @private\n * @param {Object} object The Object to iterate\n * @param {Function} fn The Function to run\n * @returns void\n */\nfunction eachObject(object, fn) {\n    var keys = Object.keys(object);\n    var l = keys.length;\n    var i = 0;\n\n    while (i < l) {\n        var currentKey = keys[i];\n\n        fn(object[currentKey], currentKey, i);\n        i++;\n    }\n}\n/**\n * replace string at position\n *\n * @private\n * @param {String} string The String to exec\n * @param {String} find The String to find\n * @param {String} replace The String to replace\n * @param {Number} index The Index to start replacing\n * @returns {String} replacedString\n */\nfunction replaceFrom(string, find, replace, index) {\n    return string.substr(0, index) + string.substr(index).replace(find, replace);\n}\n\nvar text = {\n    onBind: function onBind(ctrl, context) {\n        var result = [];\n        var nodes = getTextNodes(context);\n        var match = void 0;\n\n        //Iterate Nodes\n        nodes.forEach(function (node) {\n            //Iterate Regex\n            while ((match = _expressionRegex.exec(node.textContent)) !== null) {\n                if (match.index === _expressionRegex.lastIndex) {\n                    _expressionRegex.lastIndex++;\n                }\n\n                result.push({\n                    match: match[0],\n                    data: match[1],\n                    val: match[0],\n                    index: match.index,\n                    parent: node\n                });\n            }\n        });\n\n        return result;\n\n        //Modified version of http://stackoverflow.com/questions/10730309/find-all-text-nodes-in-html-page\n        function getTextNodes(node) {\n            var all = [];\n            for (node = node.firstChild; node; node = node.nextSibling) {\n                if (node.nodeType === 3 && node.parentNode.nodeName !== \"SCRIPT\") {\n                    all.push(node);\n                } else {\n                    all = all.concat(getTextNodes(node));\n                }\n            }\n            return all;\n        }\n    },\n    onDigest: function onDigest(ctrl, context, entry) {\n        var result = ctrl[entry.data];\n\n        entry.parent.textContent = replaceFrom(entry.parent.textContent, entry.val, result, entry.index);\n        entry.val = result;\n\n        return result;\n    }\n};\n\nvar expressions = {\n    text: text\n};\n\n/**\n * Digest & render dom\n *\n * @private\n * @param {Object} ctrl The Controller\n * @return {Node} context The Controller context\n */\nvar digest = function (ctrl) {\n    //@TODO implement debounce\n\n    iteratePlugins(directives, ctrl.$directives, function (entry, plugin) {\n        plugin.onDigest(ctrl, ctrl.$context, entry);\n    });\n\n    iteratePlugins(expressions, ctrl.$expressions, function (entry, plugin) {\n        plugin.onDigest(ctrl, ctrl.$context, entry);\n    });\n\n    function iteratePlugins(pluginData, data, fn) {\n        eachObject(pluginData, function (plugin, key) {\n            var active = data[key];\n\n            active.forEach(function (entry) {\n                fn(entry, plugin);\n            });\n        });\n    }\n};\n\n/**\n * Binds event to dom\n *\n * @private\n * @param {NodeList} domList The Elements to bind\n * @param {String} type The Event type\n * @param {Function} fn The Even function\n * @return void\n */\nvar bind = function (domList, type, fn) {\n    eachNode(domList, function (dom) {\n        dom.addEventListener(type, eventFn, false);\n\n        function eventFn(ev) {\n            return fn(ev, dom);\n        }\n    });\n};\n\nvar model = {\n    onBind: function onBind(ctrl, context) {\n        var result = [];\n        var elements = queryDirective(\"model\", \"*\", context);\n\n        bind(elements, \"change\", modelEvent);\n        bind(elements, \"input\", modelEvent);\n\n        eachNode(elements, function (element, index) {\n            result.push({\n                index: index,\n                element: element,\n                type: \"model\",\n                value: readDirective(element, \"model\")\n            });\n        });\n\n        return result;\n\n        function modelEvent(ev, dom) {\n            _window.setTimeout(function () {\n                var content = dom.value;\n                var modelFor = readDirective(dom, \"model\");\n\n                console.log(\"MODEL:\", modelFor, content);\n                ctrl[modelFor] = content;\n\n                digest(ctrl);\n            }, 5);\n        }\n    },\n    onDigest: function onDigest(ctrl, context, entry) {\n        entry.element.value = ctrl[entry.value];\n    }\n};\n\n//import changeImported from \"./change\";\n\nvar directives = {\n    model: model\n};\n\n/**\n * Binds directives to controller\n *\n * @private\n * @param {Object} ctrl The Controller\n * @return {Object} Returns bound Object\n */\nvar bindDirectives = function (ctrl) {\n    var result = {};\n\n    eachObject(directives, function (directive, key, index) {\n        result[key] = directive.onBind(ctrl, ctrl.$context);\n    });\n\n    return result;\n};\n\n/**\n * Binds expressions to controller\n *\n * @private\n * @param {Object} ctrl The Controller\n * @return {Object} Returns bound Object\n */\nvar bindExpressions = function (ctrl) {\n    var result = {};\n\n    eachObject(expressions, function (expressions$$1, key, index) {\n        result[key] = expressions$$1.onBind(ctrl, ctrl.$context);\n    });\n\n    return result;\n};\n\n/**\n * Creates typeList entry for Controller\n *\n * @private\n * @param {Object} service The service\n * @param {Object} bundle The service deps\n * @return {Function} service\n */\nvar controllerFn = function (service, bundle) {\n    //Construct Controller\n    //\n    //First value gets ignored by calling new like this, so we need to fill it\n    bundle.unshift(null);\n    //Apply into new constructor by accessing bind proto. from: http://stackoverflow.com/questions/1606797/use-of-apply-with-new-operator-is-this-possible\n    var ctrl = service.fn = new (Function.prototype.bind.apply(service.fn, bundle))();\n\n    //Bind Context\n    ctrl.$context = queryDirective(\"controller\", service.name)[0];\n    ctrl.$expressions = bindExpressions(ctrl);\n    ctrl.$directives = bindDirectives(ctrl);\n    //run first digest\n    digest(ctrl);\n\n    console.log(service);\n\n    return service;\n};\n\n/**\n * Basic Axon Constructor\n *\n * @constructor\n * @param {String} id To identify the instance\n * @returns {Object} Returns Axon instance\n */\nvar Axon = function Axon(id) {\n    var _this = this;\n\n    //Instance Id\n    _this.id = id;\n    //Instance container\n    _this.cv = new Chevron(id + \"Container\");\n    //context\n    _this.context = queryDirective(\"app\", id)[0];\n\n    //Init Axon types\n    _this.cv.extend(\"controller\", controllerFn);\n};\n\n//Bind Chevron methods directly to parent\nvar methods = [\"access\", \"extend\", \"provider\", \"service\", \"factory\", \"controller\"];\n\nmethods.forEach(function (method) {\n    Axon.prototype[method] = function () {\n        return this.cv[method].apply(this.cv, Array.from(arguments));\n    };\n});\n\nreturn Axon;\n\n}());\n\n//# sourceMappingURL=axon.js.map\n"]}