{"version":3,"sources":["axon.js"],"names":["Axon","mapNodes","entry","fn","result","recurseNodes","node","depth","container","children","childElementCount","childArr","Array","from","forEach","childNode","index","DOM_EVENT_TIMEOUT","DOM_EVENT_MODEL","DOM_ATTR_PREFIX","DOM_ATTR_HIDDEN","DOM_ATTR_VALUE","DOM_ATTR_TEXT","DOM_ATTR_HTML","LIB_STRING_QUOTES","getDirectives","attrArr","attributes","attr","name","substr","length","splitName","replace","split","push","key","opt","val","value","directiveIgnoreBoth","retrieveMethod","instance","expression","expressionSplit","methodName","methodArgs","filter","item","map","arg","evaluateExpression","methodFn","$methods","args","Error","isDefined","retrieveProp","splitExpression","reference","$data","prop","propPath","isNaN","Number","includes","method","apply","directiveIfRender","directive","console","log","propValue","Boolean","removeAttribute","setAttribute","debounce","wait","immediate","timeout","context","this","arguments","callNow","later","clearTimeout","setTimeout","getNodeValueType","bindEvent","eventType","eventFn","eventArgs","debouncedFn","nodeValueType","eventFnWrapper","event","target","addEventListener","directiveOnInit","targetMethod","directiveModelInit","targetProp","currentValue","newValue","$render","directiveModelRender","directiveBindRender","directives","ignore","init","render","if","on","model","bind","execDirectives","domMap","execMode","recurseMap","mapNode","nodeChildren","nodeDirectives","directiveRef","directiveRefFn","directiveResult","child","_this","$cache","$context","config","document","querySelector","data","methods","$init","prototype","constructor"],"mappings":"AAMA,GAAIA,MAAQ,WACZ,YAEA,IAAIC,GAAW,SAAkBC,EAAOC,GACpC,GAAIC,MACAC,EAAe,QAASA,GAAaC,EAAMC,EAAOC,GAKlD,GAJAA,EAAUF,KAAOA,EACjBE,EAAUC,YACVN,EAAGK,EAAWF,EAAMC,GAEhBD,EAAKI,kBAAmB,CACxB,GAAIC,GAAWC,MAAMC,KAAKP,EAAKG,SAE/BE,GAASG,QAAQ,SAAUC,EAAWC,GAClCR,EAAUC,SAASO,MAEnBX,EAAaU,EAAWR,EAAQ,EAAGC,EAAUC,SAASO,OAOlE,OAFAX,GAAaH,EAAO,EAAGE,GAEhBA,GAGPa,EAAoB,GACpBC,EAAkB,QAElBC,EAAkB,KAClBC,EAAkB,SAClBC,EAAiB,QACjBC,EAAgB,cAChBC,EAAgB,YAEhBC,GAAqB,IAAK,IAAM,KAEhCC,EAAgB,SAAuBnB,GACvC,GAAIoB,GAAUd,MAAMC,KAAKP,EAAKqB,YAC1BvB,IAeJ,OAbAsB,GAAQZ,QAAQ,SAAUc,GAEtB,GAAIA,EAAKC,KAAKC,OAAO,EAAGX,EAAgBY,UAAYZ,EAAiB,CACjE,GAAIa,GAAYJ,EAAKC,KAAKI,QAAQd,EAAiB,IAAIe,MAAM,IAE7D9B,GAAO+B,MACHC,IAAKJ,EAAU,GACfK,IAAKL,EAAU,KAAM,EACrBM,IAAKV,EAAKW,WAKfnC,GAGPoC,EAAsB,WACtB,OAAO,GAGPC,EAAiB,SAAwBC,EAAUC,GACnD,GAAIC,GAAkBD,EAAWb,OAAO,EAAGa,EAAWZ,OAAS,GAAGG,MAAM,KACpEW,EAAaD,EAAgB,GAC7BE,EAAaF,EAAgB,GAAGV,MAAM,KAAKa,OAAO,SAAUC,GAC5D,MAAgB,KAATA,IACRC,IAAI,SAAUC,GACb,MAAOC,GAAmBT,EAAUQ,KAEpCE,EAAWV,EAASW,SAASR,EAEjC,IAAwB,kBAAbO,GACP,OACIjD,GAAIiD,EACJE,KAAMR,EAGV,MAAM,IAAIS,OAAM,sBAAwBZ,EAAa,MAIzDa,EAAY,SAAmBlB,GAC/B,MAAsB,mBAARA,IAGdmB,EAAe,SAAsBf,EAAUC,GAC/C,GAAIe,GAAkBf,EAAWT,MAAM,KACnC9B,GACAkC,IAAK,KACLqB,UAAW,MAEXnD,EAAYkC,EAASkB,MACrBC,EAAO,MAkBX,OAhBAH,GAAgB5C,QAAQ,SAAUgD,EAAU9C,GAGxC,GAFA6C,EAAOrD,EAAUsD,IAEbN,EAAU,aASV,KAAM,IAAID,OAAM,wBAA0BZ,EAAa,IAPnD3B,GAAQ0C,EAAgB3B,OAAS,EACjCvB,EAAYqD,GAEZzD,EAAOkC,IAAMuB,EACbzD,EAAOuD,UAAYnD,KAOxBJ,GAGP+C,EAAqB,SAA4BT,EAAUC,GAC3D,GAAKoB,MAAMC,OAAOrB,IAGX,CAAA,GAAInB,EAAkByC,SAAStB,EAAWb,OAAO,EAAG,IAEvD,MAAOa,GAAWb,OAAO,EAAGa,EAAWZ,OAAS,EAC7C,IAAiD,MAA7CY,EAAWb,OAAOa,EAAWZ,OAAS,GAAY,CAEzD,GAAImC,GAASzB,EAAeC,EAAUC,EAEtC,OAAOuB,GAAO/D,GAAGgE,MAAMzB,EAAUwB,EAAOZ,MAGxC,MAAOG,GAAaf,EAAUC,GAAYL,IAX1C,MAAO0B,QAAOrB,IAelByB,EAAoB,SAA2B1B,EAAUpC,EAAM+D,GAC/DC,QAAQC,KAAK7B,EAAUpC,EAAM+D,GAC7B,IAAIG,GAAYrB,EAAmBT,EAAU2B,EAAU/B,KACnDlC,EAASqE,QAAQD,EAQrB,OANIpE,GACAE,EAAKoE,gBAAgBtD,GAErBd,EAAKqE,aAAavD,EAAiBA,GAGhChB,GAGPwE,EAAW,SAAkBzE,EAAI0E,EAAMC,GACvC,GAAIC,GAAU,MAEd,OAAO,YACH,GAAIC,GAAUC,KACV3B,EAAO1C,MAAMC,KAAKqE,WAClBC,EAAUL,IAAcC,EACxBK,EAAQ,WACRL,EAAU,KACLD,GACD3E,EAAGgE,MAAMa,EAAS1B,GAI1B+B,cAAaN,GACbA,EAAUO,WAAWF,EAAOP,GACxBM,GACAhF,EAAGgE,MAAMa,EAAS1B,KAK1BiC,EAAmB,SAA0BjF,GAC7C,MAAIkD,GAAUlD,EAAKe,IACRA,EACAmC,EAAUlD,EAAKgB,IACfA,EAEAC,GAIXiE,EAAY,SAAmBlF,EAAMmF,EAAWC,EAASC,EAAWjD,GACpE,GAAIkD,GAAchB,EAASc,EAASzE,GAChC4E,EAAgBN,EAAiBjF,GAEjCwF,EAAiB,SAAwBC,GACzC,GAAIC,GAASD,EAAMC,OACf1C,EAAO1C,MAAMC,KAAK8E,EAItB,OAFArC,GAAKnB,KAAK6D,EAAOH,GAAgBG,EAAQD,GAElCH,EAAYzB,MAAMzB,EAAUY,GAGvC,OAAOhD,GAAK2F,iBAAiBR,EAAWK,GAAgB,IAGxDI,EAAkB,SAAyBxD,EAAUpC,EAAM+D,GAC3D,GAAI8B,GAAe1D,EAAeC,EAAU2B,EAAU/B,IAItD,OAFAkD,GAAUlF,EAAM+D,EAAUhC,IAAK8D,EAAahG,GAAIgG,EAAa7C,KAAMZ,IAE5D,GAGP0D,EAAqB,SAA4B1D,EAAUpC,EAAM+D,GACjE,GAAIgC,GAAa5C,EAAaf,EAAU2B,EAAU/B,KAC9CoD,EAAU,SAAiBY,EAAcC,GACzCF,EAAW1C,UAAUU,EAAU/B,KAAOiE,EAEtCjB,WAAW,WACP5C,EAAS8D,WACVvF,GAKP,OAFAuE,GAAUlF,EAAMY,EAAiBwE,GAAUW,EAAW/D,KAAMI,IAErD,GAGP+D,EAAuB,SAA8B/D,EAAUpC,EAAM+D,GACrE,GAAIwB,GAAgBN,EAAiBjF,GACjCkE,EAAYf,EAAaf,EAAU2B,EAAU/B,IAIjD,OAFAhC,GAAKuF,GAAiBrB,EAAUlC,KAEzB,GAGPoE,EAAsB,SAA6BhE,EAAUpC,EAAM+D,GACnE,GAAIG,GAAYrB,EAAmBT,EAAU2B,EAAU/B,IAIvD,OAFAhC,GAAKqE,aAAaN,EAAUhC,IAAKmC,IAE1B,GAGPmC,GACAC,QACIC,KAAMrE,EACNsE,OAAQtE,GAEZuE,IACID,OAAQ1C,GAEZ4C,IACIH,KAAMX,GAEVe,OACIJ,KAAMT,EACNU,OAAQL,GAEZS,MACIJ,OAAQJ,IAIZS,EAAiB,SAAwBzE,EAAU0E,EAAQC,GAC3D,GAAIC,GAAa,QAASA,GAAWC,EAAShH,GAC1C,GAAIiH,GAAeD,EAAQ9G,SACvBgH,EAAiBF,EAAQZ,WACzBvG,GAAS,CAGTqH,GAAe1F,QAEfwF,EAAQZ,WAAW7F,QAAQ,SAAUuD,GACjC,GAAIqD,GAAef,EAAWtC,EAAUjC,IAExC,IAAIsF,EAAc,CAEd,GAAIC,GAAiBD,EAAaL,EAElC,IAAIM,EAAgB,CAEhB,GAAIC,GAAkBD,EAAejF,EAAU6E,EAAQjH,KAAM+D,EAExDuD,KAEDxH,GAAS,OAQzBA,GAAUoH,EAAazF,QACvByF,EAAa1G,QAAQ,SAAU+G,GAC3BP,EAAWO,EAAOtH,EAAQ,KAKtC+G,GAAWF,EAAQ,IAGnBP,EAAO,WACP,GAAIiB,GAAQ7C,IAEZ6C,GAAMC,OAAS9H,EAAS6H,EAAME,SAAU,SAAUxH,EAAWF,GAEzD,GAAIqG,GAAalF,EAAcnB,EAE/BE,GAAUmG,WAAaA,IAG3BQ,EAAeW,EAAOA,EAAMC,OAAQ,QACpCzD,QAAQC,IAAI,iBAGZuC,EAAS,WACT,GAAIgB,GAAQ7C,IAEZkC,GAAeW,EAAOA,EAAMC,OAAQ,UACpCzD,QAAQC,IAAI,mBAUZvE,EAAO,SAAciI,GACrB,GAAIH,GAAQ7C,IAEZ6C,GAAME,SAAWE,SAASC,cAAcF,EAAOjD,SAC/C8C,EAAMlE,MAAQqE,EAAOG,KACrBN,EAAMzE,SAAW4E,EAAOI,QACxBP,EAAMC,UAEND,EAAMQ,QACNR,EAAMtB,UAYV,OANAxG,GAAKuI,WACDD,MAAOzB,EACPL,QAASM,EACT0B,YAAaxI,GAGVA","file":"axon.min.js","sourcesContent":["/**\n * Axon v0.12.0\n * Author: Felix Rilling\n * Repository: git+https://github.com/FelixRilling/axonjs.git\n */\n\nvar Axon = (function () {\n'use strict';\n\nvar mapNodes = function mapNodes(entry, fn) {\n    var result = {};\n    var recurseNodes = function recurseNodes(node, depth, container) {\n        container.node = node;\n        container.children = [];\n        fn(container, node, depth);\n\n        if (node.childElementCount) {\n            var childArr = Array.from(node.children);\n\n            childArr.forEach(function (childNode, index) {\n                container.children[index] = {};\n\n                recurseNodes(childNode, depth + 1, container.children[index]);\n            });\n        }\n    };\n\n    recurseNodes(entry, 0, result);\n\n    return result;\n};\n\nvar DOM_EVENT_TIMEOUT = 20; //event timeout in ms\nvar DOM_EVENT_MODEL = \"input\";\n\nvar DOM_ATTR_PREFIX = \"x-\";\nvar DOM_ATTR_HIDDEN = \"hidden\";\nvar DOM_ATTR_VALUE = \"value\";\nvar DOM_ATTR_TEXT = \"textContent\";\nvar DOM_ATTR_HTML = \"innerHTML\";\n\nvar LIB_STRING_QUOTES = [\"'\", \"\\\"\", \"`\"];\n\nvar getDirectives = function getDirectives(node) {\n    var attrArr = Array.from(node.attributes);\n    var result = [];\n\n    attrArr.forEach(function (attr) {\n        //If is Axon attribute\n        if (attr.name.substr(0, DOM_ATTR_PREFIX.length) === DOM_ATTR_PREFIX) {\n            var splitName = attr.name.replace(DOM_ATTR_PREFIX, \"\").split(\":\");\n\n            result.push({\n                key: splitName[0],\n                opt: splitName[1] || false,\n                val: attr.value\n            });\n        }\n    });\n\n    return result;\n};\n\nvar directiveIgnoreBoth = function directiveIgnoreBoth() {\n    return false;\n};\n\nvar retrieveMethod = function retrieveMethod(instance, expression) {\n    var expressionSplit = expression.substr(0, expression.length - 1).split(\"(\");\n    var methodName = expressionSplit[0];\n    var methodArgs = expressionSplit[1].split(\",\").filter(function (item) {\n        return item !== \"\";\n    }).map(function (arg) {\n        return evaluateExpression(instance, arg);\n    });\n    var methodFn = instance.$methods[methodName];\n\n    if (typeof methodFn === \"function\") {\n        return {\n            fn: methodFn,\n            args: methodArgs\n        };\n    } else {\n        throw new Error(\"Method not found: '\" + expression + \"'\");\n    }\n};\n\nvar isDefined = function isDefined(val) {\n    return typeof val !== \"undefined\";\n};\n\nvar retrieveProp = function retrieveProp(instance, expression) {\n    var splitExpression = expression.split(\".\");\n    var result = {\n        val: null,\n        reference: null\n    };\n    var container = instance.$data;\n    var prop = void 0;\n\n    splitExpression.forEach(function (propPath, index) {\n        prop = container[propPath];\n\n        if (isDefined(\"undefined\")) {\n\n            if (index < splitExpression.length - 1) {\n                container = prop;\n            } else {\n                result.val = prop;\n                result.reference = container;\n            }\n        } else {\n            throw new Error(\"Property not found: '\" + expression + \"'\");\n        }\n    });\n\n    return result;\n};\n\nvar evaluateExpression = function evaluateExpression(instance, expression) {\n    if (!isNaN(Number(expression))) {\n        //expression is a Number\n        return Number(expression);\n    } else if (LIB_STRING_QUOTES.includes(expression.substr(0, 1))) {\n        //expression is a String\n        return expression.substr(1, expression.length - 2);\n    } else if (expression.substr(expression.length - 1) === \")\") {\n        //expression is a Method\n        var method = retrieveMethod(instance, expression);\n\n        return method.fn.apply(instance, method.args);\n    } else {\n        //expression is a Property\n        return retrieveProp(instance, expression).val;\n    }\n};\n\nvar directiveIfRender = function directiveIfRender(instance, node, directive) {\n    console.log([instance, node, directive]);\n    var propValue = evaluateExpression(instance, directive.val);\n    var result = Boolean(propValue);\n\n    if (result) {\n        node.removeAttribute(DOM_ATTR_HIDDEN);\n    } else {\n        node.setAttribute(DOM_ATTR_HIDDEN, DOM_ATTR_HIDDEN);\n    }\n\n    return result;\n};\n\nvar debounce = function debounce(fn, wait, immediate) {\n    var timeout = void 0;\n\n    return function () {\n        var context = this;\n        var args = Array.from(arguments);\n        var callNow = immediate && !timeout;\n        var later = function later() {\n            timeout = null;\n            if (!immediate) {\n                fn.apply(context, args);\n            }\n        };\n\n        clearTimeout(timeout);\n        timeout = setTimeout(later, wait);\n        if (callNow) {\n            fn.apply(context, args);\n        }\n    };\n};\n\nvar getNodeValueType = function getNodeValueType(node) {\n    if (isDefined(node[DOM_ATTR_VALUE])) {\n        return DOM_ATTR_VALUE;\n    } else if (isDefined(node[DOM_ATTR_TEXT])) {\n        return DOM_ATTR_TEXT;\n    } else {\n        return DOM_ATTR_HTML;\n    }\n};\n\nvar bindEvent = function bindEvent(node, eventType, eventFn, eventArgs, instance) {\n    var debouncedFn = debounce(eventFn, DOM_EVENT_TIMEOUT);\n    var nodeValueType = getNodeValueType(node);\n\n    var eventFnWrapper = function eventFnWrapper(event) {\n        var target = event.target;\n        var args = Array.from(eventArgs);\n\n        args.push(target[nodeValueType], target, event);\n\n        return debouncedFn.apply(instance, args);\n    };\n\n    return node.addEventListener(eventType, eventFnWrapper, false);\n};\n\nvar directiveOnInit = function directiveOnInit(instance, node, directive) {\n    var targetMethod = retrieveMethod(instance, directive.val);\n\n    bindEvent(node, directive.opt, targetMethod.fn, targetMethod.args, instance);\n\n    return true;\n};\n\nvar directiveModelInit = function directiveModelInit(instance, node, directive) {\n    var targetProp = retrieveProp(instance, directive.val);\n    var eventFn = function eventFn(currentValue, newValue) {\n        targetProp.reference[directive.val] = newValue;\n\n        setTimeout(function () {\n            instance.$render();\n        }, DOM_EVENT_TIMEOUT);\n    };\n\n    bindEvent(node, DOM_EVENT_MODEL, eventFn, [targetProp.val], instance);\n\n    return true;\n};\n\nvar directiveModelRender = function directiveModelRender(instance, node, directive) {\n    var nodeValueType = getNodeValueType(node);\n    var propValue = retrieveProp(instance, directive.val);\n\n    node[nodeValueType] = propValue.val;\n\n    return true;\n};\n\nvar directiveBindRender = function directiveBindRender(instance, node, directive) {\n    var propValue = evaluateExpression(instance, directive.val);\n\n    node.setAttribute(directive.opt, propValue);\n\n    return true;\n};\n\nvar directives = {\n    ignore: {\n        init: directiveIgnoreBoth, //Init function\n        render: directiveIgnoreBoth //Render function\n    },\n    if: {\n        render: directiveIfRender\n    },\n    on: {\n        init: directiveOnInit\n    },\n    model: {\n        init: directiveModelInit,\n        render: directiveModelRender\n    },\n    bind: {\n        render: directiveBindRender\n    }\n};\n\nvar execDirectives = function execDirectives(instance, domMap, execMode) {\n    var recurseMap = function recurseMap(mapNode, depth) {\n        var nodeChildren = mapNode.children;\n        var nodeDirectives = mapNode.directives;\n        var result = true;\n\n        //Exec on node\n        if (nodeDirectives.length) {\n            //Only exec if directives on domNode\n            mapNode.directives.forEach(function (directive) {\n                var directiveRef = directives[directive.key];\n\n                if (directiveRef) {\n                    //Only exec if directive exists\n                    var directiveRefFn = directiveRef[execMode];\n\n                    if (directiveRefFn) {\n                        //Only exec if directive has fn for current execMode\n                        var directiveResult = directiveRefFn(instance, mapNode.node, directive);\n\n                        if (!directiveResult) {\n                            //Stop crawling on directive return 'false'\n                            result = false;\n                        }\n                    }\n                }\n            });\n        }\n\n        //Crawl children\n        if (result && nodeChildren.length) {\n            nodeChildren.forEach(function (child) {\n                recurseMap(child, depth + 1);\n            });\n        }\n    };\n\n    recurseMap(domMap, 0);\n};\n\nvar init = function init() {\n    var _this = this;\n\n    _this.$cache = mapNodes(_this.$context, function (container, node) {\n        //Cache all nodes & directives in the context\n        var directives = getDirectives(node);\n\n        container.directives = directives;\n    });\n\n    execDirectives(_this, _this.$cache, \"init\");\n    console.log(\"CALLED $init\");\n};\n\nvar render = function render() {\n    var _this = this;\n\n    execDirectives(_this, _this.$cache, \"render\");\n    console.log(\"CALLED $render\");\n};\n\n/**\n * Basic Axon Constructor\n *\n * @constructor\n * @param {String} id To identify the instance\n * @returns {Object} Returns Axon instance\n */\nvar Axon = function Axon(config) {\n    var _this = this;\n\n    _this.$context = document.querySelector(config.context);\n    _this.$data = config.data;\n    _this.$methods = config.methods;\n    _this.$cache = {};\n\n    _this.$init();\n    _this.$render();\n};\n\n/**\n * Expose Axon methods\n */\nAxon.prototype = {\n    $init: init,\n    $render: render,\n    constructor: Axon\n};\n\nreturn Axon;\n\n}());\n\n//# sourceMappingURL=axon.js.map\n"]}