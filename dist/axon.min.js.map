{"version":3,"sources":["/dist/axon.js"],"names":["Axon","directiveIgnoreBoth","DOM_EVENT_TIMEOUT","DOM_EVENT_MODEL","DOM_ATTR_PREFIX","DOM_ATTR_HIDDEN","DOM_ATTR_VALUE","DOM_ATTR_TEXT","DOM_ATTR_HTML","LIB_STRING_QUOTES","retrieveMethod","instance","expression","expressionSplit","substr","length","split","methodName","methodArgs","filter","item","map","arg","evaluateExpression","methodFn","$methods","fn","args","Error","isDefined","val","retrieveProp","splitExpression","result","ref","container","$data","prop","forEach","propPath","index","isNaN","Number","includes","method","apply","directiveIfRender","node","directive","propValue","Boolean","removeAttribute","setAttribute","arrayFrom","arr","Array","from","debounce","wait","immediate","timeout","context","this","arguments","callNow","later","clearTimeout","setTimeout","getNodeValueType","bindEvent","eventType","eventFn","eventArgs","debouncedFn","nodeValueType","eventFnWrapper","event","target","push","addEventListener","directiveOnInit","targetMethod","opt","directiveModelInit","targetProp","currentValue","newValue","$render","directiveModelRender","directiveBindRender","directives","ignore","init","render","if","on","model","bind","execDirectives","domMap","execMode","recurseMap","mapNode","nodeChildren","children","nodeDirectives","directiveRef","key","directiveRefFn","directiveResult","child","getDirectives","attrArr","attributes","attr","name","splitName","replace","value","_typeof","Symbol","iterator","obj","constructor","prototype","getDomMap","entry","recurseNodes","_ret","childArr","childNode","childResult","v","_this","$cache","$context","console","log","config","document","querySelector","data","methods","$init"],"mappings":"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","file":"axon.min.js","sourcesContent":["/**\n * Axon v0.17.0\n * Author: Felix Rilling\n * Repository: git+https://github.com/FelixRilling/axonjs.git\n */\n\nvar Axon = (function () {\n'use strict';\n\nvar directiveIgnoreBoth = function directiveIgnoreBoth() {\n    return false;\n};\n\nvar DOM_EVENT_TIMEOUT = 20; //event timeout in ms\nvar DOM_EVENT_MODEL = \"input\";\n\nvar DOM_ATTR_PREFIX = \"x-\";\nvar DOM_ATTR_HIDDEN = \"hidden\";\nvar DOM_ATTR_VALUE = \"value\";\nvar DOM_ATTR_TEXT = \"textContent\";\nvar DOM_ATTR_HTML = \"innerHTML\";\n\nvar LIB_STRING_QUOTES = [\"'\", \"\\\"\", \"`\"];\n\nvar retrieveMethod = function retrieveMethod(instance, expression) {\n    var expressionSplit = expression.substr(0, expression.length - 1).split(\"(\");\n    var methodName = expressionSplit[0];\n    var methodArgs = expressionSplit[1].split(\",\").filter(function (item) {\n        return item !== \"\";\n    }).map(function (arg) {\n        return evaluateExpression(instance, arg);\n    });\n    var methodFn = instance.$methods[methodName];\n\n    if (typeof methodFn === \"function\") {\n        return {\n            fn: methodFn,\n            args: methodArgs\n        };\n    } else {\n        throw new Error(\"Missing method '\" + expression + \"'\");\n    }\n};\n\nvar isDefined = function isDefined(val) {\n    return typeof val !== \"undefined\";\n};\n\nvar retrieveProp = function retrieveProp(instance, expression) {\n    var splitExpression = expression.split(\".\");\n    var result = {\n        val: null,\n        ref: null\n    };\n    var container = instance.$data;\n    var prop = void 0;\n\n    splitExpression.forEach(function (propPath, index) {\n        prop = container[propPath];\n\n        if (isDefined(prop)) {\n\n            if (index < splitExpression.length - 1) {\n                container = prop;\n            } else {\n                result.val = prop;\n                result.ref = container;\n            }\n        } else {\n            throw new Error(\"Missing prop '\" + expression + \"'\");\n        }\n    });\n\n    //console.log(expression,result);\n\n    return result;\n};\n\nvar evaluateExpression = function evaluateExpression(instance, expression) {\n\n    if (!isNaN(Number(expression))) {\n        //expression is a Number\n        return Number(expression);\n    } else if (LIB_STRING_QUOTES.includes(expression.substr(0, 1))) {\n        //expression is a String\n        return expression.substr(1, expression.length - 2);\n    } else if (expression.substr(expression.length - 1) === \")\") {\n        //expression is a Method\n        var method = retrieveMethod(instance, expression);\n\n        return method.fn.apply(instance, method.args);\n    } else {\n        //expression is a Property\n        return retrieveProp(instance, expression).val;\n    }\n};\n\nvar directiveIfRender = function directiveIfRender(instance, node, directive) {\n    var propValue = evaluateExpression(instance, directive.val);\n    var result = Boolean(propValue);\n\n    if (result) {\n        node.removeAttribute(DOM_ATTR_HIDDEN);\n    } else {\n        node.setAttribute(DOM_ATTR_HIDDEN, DOM_ATTR_HIDDEN);\n    }\n\n    return result;\n};\n\nvar arrayFrom = function arrayFrom(arr) {\n    return Array.from(arr);\n};\n\nvar debounce = function debounce(fn, wait, immediate) {\n    var timeout = void 0;\n\n    return function () {\n        var context = this;\n        var args = arrayFrom(arguments);\n        var callNow = immediate && !timeout;\n        var later = function later() {\n            timeout = null;\n            if (!immediate) {\n                fn.apply(context, args);\n            }\n        };\n\n        clearTimeout(timeout);\n        timeout = setTimeout(later, wait);\n        if (callNow) {\n            fn.apply(context, args);\n        }\n    };\n};\n\nvar getNodeValueType = function getNodeValueType(node) {\n    if (isDefined(node[DOM_ATTR_VALUE])) {\n        return DOM_ATTR_VALUE;\n    } else if (isDefined(node[DOM_ATTR_TEXT])) {\n        return DOM_ATTR_TEXT;\n    } else {\n        return DOM_ATTR_HTML;\n    }\n};\n\nvar bindEvent = function bindEvent(node, eventType, eventFn, eventArgs, instance) {\n    var debouncedFn = debounce(eventFn, DOM_EVENT_TIMEOUT);\n    var nodeValueType = getNodeValueType(node);\n\n    var eventFnWrapper = function eventFnWrapper(event) {\n        var target = event.target;\n        var args = arrayFrom(eventArgs);\n\n        args.push(target[nodeValueType], target, event);\n\n        return debouncedFn.apply(instance, args);\n    };\n\n    return node.addEventListener(eventType, eventFnWrapper, false);\n};\n\nvar directiveOnInit = function directiveOnInit(instance, node, directive) {\n    var targetMethod = retrieveMethod(instance, directive.val);\n\n    bindEvent(node, directive.opt, targetMethod.fn, targetMethod.args, instance);\n\n    return true;\n};\n\nvar directiveModelInit = function directiveModelInit(instance, node, directive) {\n    var targetProp = retrieveProp(instance, directive.val);\n    var eventFn = function eventFn(currentValue, newValue) {\n        targetProp.ref[directive.val] = newValue;\n\n        setTimeout(function () {\n            instance.$render();\n        }, DOM_EVENT_TIMEOUT);\n    };\n\n    bindEvent(node, DOM_EVENT_MODEL, eventFn, [targetProp.val], instance);\n\n    return true;\n};\n\nvar directiveModelRender = function directiveModelRender(instance, node, directive) {\n    var nodeValueType = getNodeValueType(node);\n    var propValue = retrieveProp(instance, directive.val);\n\n    node[nodeValueType] = propValue.val;\n\n    return true;\n};\n\nvar directiveBindRender = function directiveBindRender(instance, node, directive) {\n    var propValue = evaluateExpression(instance, directive.val);\n\n    node.setAttribute(directive.opt, propValue);\n\n    return true;\n};\n\n/*import {\n    directiveForInit,\n    directiveForRender\n} from \"./modules/directiveFor\";*/\n\nvar directives = {\n    ignore: {\n        init: directiveIgnoreBoth, //Init function\n        render: directiveIgnoreBoth //Render function\n    },\n    if: {\n        render: directiveIfRender\n    },\n    on: {\n        init: directiveOnInit\n    },\n    model: {\n        init: directiveModelInit,\n        render: directiveModelRender\n    },\n    bind: {\n        render: directiveBindRender\n    }\n};\n\nvar execDirectives = function execDirectives(instance, domMap, execMode) {\n    var recurseMap = function recurseMap(mapNode) {\n        var nodeChildren = mapNode.children;\n        var nodeDirectives = mapNode.directives;\n        var result = true;\n\n        //Exec on node\n        if (nodeDirectives.length) {\n            //Only exec if directives on domNode\n            mapNode.directives.forEach(function (directive) {\n                var directiveRef = directives[directive.key];\n\n                if (directiveRef) {\n                    //Only exec if directive exists\n                    var directiveRefFn = directiveRef[execMode];\n\n                    if (directiveRefFn) {\n                        //Only exec if directive has fn for current execMode\n                        var directiveResult = directiveRefFn(instance, mapNode.node, directive);\n\n                        if (!directiveResult) {\n                            //Stop crawling on directive return 'false'\n                            result = false;\n                        }\n                    }\n                }\n            });\n        }\n\n        //Crawl children\n        if (result && nodeChildren.length) {\n            nodeChildren.forEach(function (child) {\n                recurseMap(child);\n            });\n        }\n    };\n\n    recurseMap(domMap);\n};\n\nvar getDirectives = function getDirectives(node) {\n    var attrArr = arrayFrom(node.attributes);\n    var result = [];\n\n    attrArr.forEach(function (attr) {\n        //If is Axon attribute\n        if (attr.name.substr(0, DOM_ATTR_PREFIX.length) === DOM_ATTR_PREFIX) {\n            var splitName = attr.name.replace(DOM_ATTR_PREFIX, \"\").split(\":\");\n\n            result.push({\n                key: splitName[0],\n                opt: splitName[1] || false,\n                val: attr.value\n            });\n        }\n    });\n\n    return result;\n};\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\nvar getDomMap = function getDomMap(entry) {\n    var recurseNodes = function recurseNodes(node) {\n        var nodeDirectives = getDirectives(node);\n        var nodeChildren = node.children;\n\n        if (nodeDirectives.length || nodeChildren.length) {\n            var _ret = function () {\n                var result = {\n                    node: node,\n                    directives: nodeDirectives,\n                    children: []\n                };\n                var childArr = arrayFrom(nodeChildren);\n\n                childArr.forEach(function (childNode) {\n                    var childResult = recurseNodes(childNode);\n\n                    if (isDefined(childResult)) {\n                        result.children.push(childResult);\n                    }\n                });\n\n                return {\n                    v: result\n                };\n            }();\n\n            if ((typeof _ret === \"undefined\" ? \"undefined\" : _typeof(_ret)) === \"object\") return _ret.v;\n        }\n    };\n\n    return recurseNodes(entry);\n};\n\nvar init = function init() {\n  var _this = this;\n\n  _this.$cache = getDomMap(_this.$context);\n  execDirectives(_this, _this.$cache, \"init\");\n  console.log(\"CALLED $init\");\n};\n\nvar render = function render() {\n    var _this = this;\n\n    execDirectives(_this, _this.$cache, \"render\");\n    console.log(\"CALLED $render\");\n};\n\n/**\n * Basic Axon Constructor\n *\n * @constructor\n * @param {String} id To identify the instance\n * @returns {Object} Returns Axon instance\n */\nvar Axon = function Axon(config) {\n    var _this = this;\n\n    _this.$context = document.querySelector(config.context);\n    _this.$data = config.data;\n    _this.$methods = config.methods;\n    _this.$cache = {};\n\n    _this.$init();\n    _this.$render();\n};\n\n/**\n * Expose Axon methods\n */\nAxon.prototype = {\n    $init: init,\n    $render: render,\n    constructor: Axon\n};\n\nreturn Axon;\n\n}());\n\n//# sourceMappingURL=axon.js.map\n"]}