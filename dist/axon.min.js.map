{"version":3,"sources":["axon.js"],"names":["Axon","directiveIgnoreBoth","DOM_EVENT_TIMEOUT","DOM_EVENT_MODEL","DOM_ATTR_PREFIX","DOM_ATTR_HIDDEN","DOM_ATTR_VALUE","DOM_ATTR_TEXT","DOM_ATTR_HTML","LIB_STRING_QUOTES","retrieveMethod","instance","expression","expressionSplit","substr","length","split","methodName","methodArgs","filter","item","map","arg","evaluateExpression","methodFn","$methods","fn","args","Error","isDefined","val","retrieveProp","splitExpression","result","reference","container","$data","prop","forEach","propPath","index","isNaN","Number","includes","method","apply","directiveIfRender","node","directive","propValue","Boolean","removeAttribute","setAttribute","debounce","wait","immediate","timeout","context","this","Array","from","arguments","callNow","later","clearTimeout","setTimeout","getNodeValueType","bindEvent","eventType","eventFn","eventArgs","debouncedFn","nodeValueType","eventFnWrapper","event","target","push","addEventListener","directiveOnInit","targetMethod","opt","directiveModelInit","targetProp","currentValue","newValue","$render","directiveModelRender","directiveBindRender","directives","ignore","init","render","if","on","model","bind","execDirectives","domMap","execMode","recurseMap","mapNode","nodeChildren","children","nodeDirectives","directiveRef","key","directiveRefFn","directiveResult","child","getDirectives","attrArr","attributes","attr","name","splitName","replace","value","_typeof","Symbol","iterator","obj","constructor","prototype","getDomMap","entry","recurseNodes","childElementCount","_ret","childArr","childNode","childResult","v","_this","$cache","$context","console","log","config","document","querySelector","data","methods","$init"],"mappings":"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","file":"axon.min.js","sourcesContent":["/**\n * Axon v0.14.0\n * Author: Felix Rilling\n * Repository: git+https://github.com/FelixRilling/axonjs.git\n */\n\nvar Axon = (function () {\n'use strict';\n\nvar directiveIgnoreBoth = function directiveIgnoreBoth() {\n    return false;\n};\n\nvar DOM_EVENT_TIMEOUT = 20; //event timeout in ms\nvar DOM_EVENT_MODEL = \"input\";\n\nvar DOM_ATTR_PREFIX = \"x-\";\nvar DOM_ATTR_HIDDEN = \"hidden\";\nvar DOM_ATTR_VALUE = \"value\";\nvar DOM_ATTR_TEXT = \"textContent\";\nvar DOM_ATTR_HTML = \"innerHTML\";\n\nvar LIB_STRING_QUOTES = [\"'\", \"\\\"\", \"`\"];\n\nvar retrieveMethod = function retrieveMethod(instance, expression) {\n    var expressionSplit = expression.substr(0, expression.length - 1).split(\"(\");\n    var methodName = expressionSplit[0];\n    var methodArgs = expressionSplit[1].split(\",\").filter(function (item) {\n        return item !== \"\";\n    }).map(function (arg) {\n        return evaluateExpression(instance, arg);\n    });\n    var methodFn = instance.$methods[methodName];\n\n    if (typeof methodFn === \"function\") {\n        return {\n            fn: methodFn,\n            args: methodArgs\n        };\n    } else {\n        throw new Error(\"Method not found: '\" + expression + \"'\");\n    }\n};\n\nvar isDefined = function isDefined(val) {\n    return typeof val !== \"undefined\";\n};\n\nvar retrieveProp = function retrieveProp(instance, expression) {\n    var splitExpression = expression.split(\".\");\n    var result = {\n        val: null,\n        reference: null\n    };\n    var container = instance.$data;\n    var prop = void 0;\n\n    splitExpression.forEach(function (propPath, index) {\n        prop = container[propPath];\n\n        if (isDefined(\"undefined\")) {\n\n            if (index < splitExpression.length - 1) {\n                container = prop;\n            } else {\n                result.val = prop;\n                result.reference = container;\n            }\n        } else {\n            throw new Error(\"Property not found: '\" + expression + \"'\");\n        }\n    });\n\n    return result;\n};\n\nvar evaluateExpression = function evaluateExpression(instance, expression) {\n    if (!isNaN(Number(expression))) {\n        //expression is a Number\n        return Number(expression);\n    } else if (LIB_STRING_QUOTES.includes(expression.substr(0, 1))) {\n        //expression is a String\n        return expression.substr(1, expression.length - 2);\n    } else if (expression.substr(expression.length - 1) === \")\") {\n        //expression is a Method\n        var method = retrieveMethod(instance, expression);\n\n        return method.fn.apply(instance, method.args);\n    } else {\n        //expression is a Property\n        return retrieveProp(instance, expression).val;\n    }\n};\n\nvar directiveIfRender = function directiveIfRender(instance, node, directive) {\n    var propValue = evaluateExpression(instance, directive.val);\n    var result = Boolean(propValue);\n\n    if (result) {\n        node.removeAttribute(DOM_ATTR_HIDDEN);\n    } else {\n        node.setAttribute(DOM_ATTR_HIDDEN, DOM_ATTR_HIDDEN);\n    }\n\n    return result;\n};\n\nvar debounce = function debounce(fn, wait, immediate) {\n    var timeout = void 0;\n\n    return function () {\n        var context = this;\n        var args = Array.from(arguments);\n        var callNow = immediate && !timeout;\n        var later = function later() {\n            timeout = null;\n            if (!immediate) {\n                fn.apply(context, args);\n            }\n        };\n\n        clearTimeout(timeout);\n        timeout = setTimeout(later, wait);\n        if (callNow) {\n            fn.apply(context, args);\n        }\n    };\n};\n\nvar getNodeValueType = function getNodeValueType(node) {\n    if (isDefined(node[DOM_ATTR_VALUE])) {\n        return DOM_ATTR_VALUE;\n    } else if (isDefined(node[DOM_ATTR_TEXT])) {\n        return DOM_ATTR_TEXT;\n    } else {\n        return DOM_ATTR_HTML;\n    }\n};\n\nvar bindEvent = function bindEvent(node, eventType, eventFn, eventArgs, instance) {\n    var debouncedFn = debounce(eventFn, DOM_EVENT_TIMEOUT);\n    var nodeValueType = getNodeValueType(node);\n\n    var eventFnWrapper = function eventFnWrapper(event) {\n        var target = event.target;\n        var args = Array.from(eventArgs);\n\n        args.push(target[nodeValueType], target, event);\n\n        return debouncedFn.apply(instance, args);\n    };\n\n    return node.addEventListener(eventType, eventFnWrapper, false);\n};\n\nvar directiveOnInit = function directiveOnInit(instance, node, directive) {\n    var targetMethod = retrieveMethod(instance, directive.val);\n\n    bindEvent(node, directive.opt, targetMethod.fn, targetMethod.args, instance);\n\n    return true;\n};\n\nvar directiveModelInit = function directiveModelInit(instance, node, directive) {\n    var targetProp = retrieveProp(instance, directive.val);\n    var eventFn = function eventFn(currentValue, newValue) {\n        targetProp.reference[directive.val] = newValue;\n\n        setTimeout(function () {\n            instance.$render();\n        }, DOM_EVENT_TIMEOUT);\n    };\n\n    bindEvent(node, DOM_EVENT_MODEL, eventFn, [targetProp.val], instance);\n\n    return true;\n};\n\nvar directiveModelRender = function directiveModelRender(instance, node, directive) {\n    var nodeValueType = getNodeValueType(node);\n    var propValue = retrieveProp(instance, directive.val);\n\n    node[nodeValueType] = propValue.val;\n\n    return true;\n};\n\nvar directiveBindRender = function directiveBindRender(instance, node, directive) {\n    var propValue = evaluateExpression(instance, directive.val);\n\n    node.setAttribute(directive.opt, propValue);\n\n    return true;\n};\n\nvar directives = {\n    ignore: {\n        init: directiveIgnoreBoth, //Init function\n        render: directiveIgnoreBoth //Render function\n    },\n    if: {\n        render: directiveIfRender\n    },\n    on: {\n        init: directiveOnInit\n    },\n    model: {\n        init: directiveModelInit,\n        render: directiveModelRender\n    },\n    bind: {\n        render: directiveBindRender\n    }\n};\n\nvar execDirectives = function execDirectives(instance, domMap, execMode) {\n    var recurseMap = function recurseMap(mapNode) {\n        var nodeChildren = mapNode.children;\n        var nodeDirectives = mapNode.directives;\n        var result = true;\n\n        //Exec on node\n        if (nodeDirectives.length) {\n            //Only exec if directives on domNode\n            mapNode.directives.forEach(function (directive) {\n                var directiveRef = directives[directive.key];\n\n                if (directiveRef) {\n                    //Only exec if directive exists\n                    var directiveRefFn = directiveRef[execMode];\n\n                    if (directiveRefFn) {\n                        //Only exec if directive has fn for current execMode\n                        var directiveResult = directiveRefFn(instance, mapNode.node, directive);\n\n                        if (!directiveResult) {\n                            //Stop crawling on directive return 'false'\n                            result = false;\n                        }\n                    }\n                }\n            });\n        }\n\n        //Crawl children\n        if (result && nodeChildren.length) {\n            nodeChildren.forEach(function (child) {\n                recurseMap(child);\n            });\n        }\n    };\n\n    recurseMap(domMap);\n};\n\nvar getDirectives = function getDirectives(node) {\n    var attrArr = Array.from(node.attributes);\n    var result = [];\n\n    attrArr.forEach(function (attr) {\n        //If is Axon attribute\n        if (attr.name.substr(0, DOM_ATTR_PREFIX.length) === DOM_ATTR_PREFIX) {\n            var splitName = attr.name.replace(DOM_ATTR_PREFIX, \"\").split(\":\");\n\n            result.push({\n                key: splitName[0],\n                opt: splitName[1] || false,\n                val: attr.value\n            });\n        }\n    });\n\n    return result;\n};\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\nvar getDomMap = function getDomMap(entry) {\n    var recurseNodes = function recurseNodes(node) {\n        var directives = getDirectives(node);\n\n        if (directives.length || node.childElementCount) {\n            var _ret = function () {\n                var result = {};\n                var childArr = Array.from(node.children);\n\n                result.node = node;\n                result.children = [];\n                result.directives = directives;\n\n                //console.log(result);\n\n                childArr.forEach(function (childNode) {\n                    var childResult = recurseNodes(childNode);\n\n                    if (childResult.node) {\n                        result.children.push(childResult);\n                    }\n                });\n\n                return {\n                    v: result\n                };\n            }();\n\n            if ((typeof _ret === \"undefined\" ? \"undefined\" : _typeof(_ret)) === \"object\") return _ret.v;\n        } else {\n            return false;\n        }\n    };\n\n    return recurseNodes(entry, {});\n};\n\nvar init = function init() {\n  var _this = this;\n\n  _this.$cache = getDomMap(_this.$context);\n\n  execDirectives(_this, _this.$cache, \"init\");\n  console.log(\"CALLED $init\");\n};\n\nvar render = function render() {\n    var _this = this;\n\n    execDirectives(_this, _this.$cache, \"render\");\n    console.log(\"CALLED $render\");\n};\n\n/**\n * Basic Axon Constructor\n *\n * @constructor\n * @param {String} id To identify the instance\n * @returns {Object} Returns Axon instance\n */\nvar Axon = function Axon(config) {\n    var _this = this;\n\n    _this.$context = document.querySelector(config.context);\n    _this.$data = config.data;\n    _this.$methods = config.methods;\n    _this.$cache = {};\n\n    _this.$init();\n    _this.$render();\n};\n\n/**\n * Expose Axon methods\n */\nAxon.prototype = {\n    $init: init,\n    $render: render,\n    constructor: Axon\n};\n\nreturn Axon;\n\n}());\n\n//# sourceMappingURL=axon.js.map\n"]}