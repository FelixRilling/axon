{"version":3,"sources":["axon.js"],"names":[],"mappings":";;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"axon.js","sourcesContent":["var Axon = (function () {\n'use strict';\n\nvar _document = document;\n\nvar DOM_PREFIX = \"x-\";\nvar DEBOUNCE_TIMEOUT = 40; //event timeout in ms\n\n/**\r\n * iterate over NodeList\r\n *\r\n * @private\r\n * @param {NodeList} nodeList The nodeList to iterate over\r\n * @param {Function} fn The Function to call\r\n * @returns void\r\n */\nvar eachNode = function eachNode(nodeList, fn) {\n    var l = nodeList.length;\n    var i = 0;\n\n    while (i < l) {\n        fn(nodeList[i], i);\n        i++;\n    }\n};\n\n/**\r\n * Iterate over NamedNodeMap\r\n *\r\n * @private\r\n * @param {NamedNodeMap} namedNodeMap The NamedNodeMap to iterate over\r\n * @param {Function} fn The Function to run\r\n * @returns void\r\n */\nvar eachAttribute = function eachAttribute(namedNodeMap, fn) {\n    var l = namedNodeMap.length;\n    var i = 0;\n\n    while (i < l) {\n        var item = namedNodeMap.item(i);\n\n        fn(item.name, item.value, i);\n        i++;\n    }\n};\n\nvar crawlNodes = function crawlNodes(entry, fn) {\n    var recurseNodes = function recurseNodes(node, fn) {\n        var children = node.children;\n\n        if (children && children.length > 0) {\n            var result = true;\n\n            result = eachNode(children, function (childNode) {\n                return recurseNodes(childNode, fn);\n            });\n\n            return result;\n        } else {\n            return fn(node);\n        }\n    };\n\n    return recurseNodes(entry, fn);\n};\n\nvar eachDirective = function eachDirective(node, allowedNames, fn) {\n    eachAttribute(node.attributes, function (attributeName, attributeValue) {\n\n        //If is Axon attribute\n        if (attributeName.substr(0, DOM_PREFIX.length) === DOM_PREFIX) {\n            var splitName = attributeName.replace(DOM_PREFIX, \"\").split(\":\");\n\n            //If name is allowed\n            if (allowedNames.indexOf(splitName[0]) !== -1) {\n                fn({\n                    name: splitName[0],\n                    secondary: splitName[1],\n                    value: attributeValue\n                });\n            }\n        }\n    });\n};\n\nvar debounce = function debounce(fn, wait, immediate) {\n    var timeout = void 0;\n\n    return function () {\n        var context = this;\n        var args = Array.from(arguments);\n        var callNow = immediate && !timeout;\n        var later = function later() {\n            timeout = null;\n            if (!immediate) {\n                fn.apply(context, args);\n            }\n        };\n\n        clearTimeout(timeout);\n        timeout = setTimeout(later, wait);\n        if (callNow) {\n            fn.apply(context, args);\n        }\n    };\n};\n\nvar getNodeValueType = function getNodeValueType(node) {\n    if (typeof node.value !== \"undefined\") {\n        return \"value\";\n    } else if (typeof node.textContent !== \"undefined\") {\n        return \"textContent\";\n    } else {\n        return \"innerHTML\";\n    }\n};\n\nvar bindEvent = function bindEvent(node, eventType, eventFn, eventArgs, instance) {\n    var debouncedFn = debounce(eventFn, DEBOUNCE_TIMEOUT);\n    var nodeValueType = getNodeValueType(node);\n\n    var eventFnWrapper = function eventFnWrapper(event) {\n        var target = event.target;\n        var args = Array.from(eventArgs);\n\n        args.push(target[nodeValueType], target, event);\n\n        return debouncedFn.apply(instance, args);\n    };\n\n    return node.addEventListener(eventType, eventFnWrapper, false);\n};\n\nvar retrieveProp = function retrieveProp(instance, propName) {\n    var castNumber = Number(propName);\n    var stringChars = [\"'\", \"\\\"\", \"`\"];\n\n    if (!isNaN(castNumber)) {\n        //If number\n        return castNumber;\n    } else if (stringChars.includes(propName[0])) {\n        //If String\n        return propName.substr(1, propName.length - 2);\n    } else {\n        //If prop\n        var prop = instance.$data[propName];\n\n        if (typeof prop === \"undefined\") {\n            throw new Error(\"prop '\" + propName + \"' not found\");\n        } else {\n            return prop;\n        }\n    }\n\n    return null;\n};\n\nvar retrieveMethod = function retrieveMethod(instance, methodString) {\n    var methodStringSplit = methodString.substr(0, methodString.length - 1).split(\"(\");\n    var methodName = methodStringSplit[0];\n    var methodArgs = methodStringSplit[1].split(\",\").filter(function (item) {\n        return item !== \"\";\n    }).map(function (arg) {\n        return retrieveProp(instance, arg);\n    });\n\n    var methodFn = instance.$methods[methodName];\n\n    if (typeof methodFn !== \"function\") {\n        throw new Error(\"method '\" + methodName + \"' not found\");\n    } else {\n        return {\n            fn: methodFn,\n            args: methodArgs\n        };\n    }\n};\n\nvar init = function init() {\n    var _this = this;\n\n    //Bind events\n    crawlNodes(_this.$context, function (node) {\n        eachDirective(node, [\"on\"], function (directive) {\n            var targetMethod = retrieveMethod(_this, directive.value);\n\n            bindEvent(node, directive.secondary, targetMethod.fn, targetMethod.args, _this);\n        });\n    });\n\n    console.log(\"CALLED $init\");\n};\n\nvar model = function model(instance, node, propName) {\n    var nodeValueType = getNodeValueType(node);\n    var propValue = retrieveProp(instance, propName);\n\n    node[nodeValueType] = propValue;\n};\n\nvar render = function render() {\n    var _this = this;\n\n    //Bind events\n    crawlNodes(_this.$context, function (node) {\n        eachDirective(node, [\"model\"], function (directive) {\n            if (directive.name === \"model\") {\n                model(_this, node, directive.value);\n            }\n        });\n    });\n\n    console.log(\"CALLED $render\");\n};\n\n/**\r\n * Basic Axon Constructor\r\n *\r\n * @constructor\r\n * @param {String} id To identify the instance\r\n * @returns {Object} Returns Axon instance\r\n */\nvar Axon = function Axon(appConfig) {\n    var _this = this;\n\n    _this.$context = _document.querySelector(appConfig.context);\n    _this.$data = appConfig.data;\n    _this.$methods = appConfig.methods;\n\n    _this.$init();\n    _this.$render();\n};\n\n/**\r\n * Expose Axon methods\r\n */\nAxon.prototype = {\n    $init: init,\n    $render: render,\n    constructor: Axon\n};\n\nreturn Axon;\n\n}());\n"]}