{"version":3,"sources":["es6/axon.js"],"names":[],"mappings":"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","file":"axon.js","sourcesContent":["var Axon = (function () {\n    'use strict';\n\n    /**\r\n         * Store strings to avoid duplicate strings\r\n         */\r\n        const _more = \": \";\r\n        const _error = \"error in \";\r\n        const _factory = \"factory\";\r\n        const _service = \"service\";\r\n        const _isUndefined = \" is undefined\";\n\n    /**\n         * Checks if service exist, else add it\n         *\n         * @param {String} type The type of the service (service/factory)\n         * @param {Function} cf The Constructor function of the service\n         * @param {String} name The name to register/id the service\n         * @param {Array} deps List of dependencies\n         * @param {Function} fn Content of the service\n         * @returns {Object} Returns `this`\n         */\n    function provider (type, cf, name, deps, fn) {\n            const _this = this;\n\n            if (_this.chev[name]) {\n                //throw error if a service with this name already exists\n                throw _this.id + _more + _error + name + \" already exists\";\n            } else {\n                //Add the service to container\n                _this.chev[name] = {\n                    type,\n                    cf,\n                    name,\n                    deps,\n                    fn,\n                    init: false\n                };\n\n                return _this;\n            }\n        }\n\n    /**\n         * Adds a new service type\n         *\n         * @param {String} type The name of the type\n         * @param {Function} cf Constructor function to init the service with\n         * @returns {Object} Returns `this`\n         */\n    function extend (type, cf) {\n            const _this = this;\n\n            //Add customType method to container\n            _this[type] = function (name, deps, fn) {\n                return _this.provider(type, cf, name, deps, fn);\n            };\n\n            return _this;\n        }\n\n    /**\n         * Collects dependencies and initializes service\n         *\n         * @private\n         * @param {Object} _this The context\n         * @param {Object} service The service to check\n         * @param {Object} list The list of dependencies\n         * @returns {Object} Returns `service`\n         */\n    function initialize (_this, service, list) {\n            if (!service.init) {\n                const bundle = [];\r\n\n                //Collect an ordered Array of dependencies\n                service.deps.forEach(item => {\n                    const dependency = list[item];\n\n                    if (dependency) {\n                        bundle.push(dependency.fn);\n                    }\n                });\n\n                //Init service\n                //Call Constructor fn with service/deps\n                service = service.cf(service, bundle);\n                service.init = true;\n            }\n\n            return service;\n        }\n\n    /**\n         * Loops trough dependencies, recurse if new dependencies has dependencies itself; then execute fn.\n         *\n         * @private\n         * @param {Object} _this The context\n         * @param {Array} service The dependencyList to iterate\n         * @param {Function} fn The function run over each dependency\n         * @returns void\n         */\n        function recurseDependencies(_this, service, fn) {\n            //loop trough deps\n            service.deps.forEach(name => {\n                const dependency = _this.chev[name];\n\n                if (dependency) {\n                    //recurse over sub-deps\n                    recurseDependencies(_this, dependency, fn);\n                    //run fn\n                    fn(dependency);\n                } else {\n                    //if not found error with name\n                    throw _this.id + _more + _error + service.name + _more + \"dependency \" + name + _isUndefined;\n                }\n            });\n        }\n\n    /**\n         * Check if every dependency is available\n         *\n         * @private\n         * @param {Object} _this The context\n         * @param {Object} service The service to prepare\n         * @returns {Object} Initialized service\n         */\n    function prepare(_this, service) {\n            const list = {};\n\n            //Recurse trough service deps\n            recurseDependencies(\n                _this,\n                service,\n                //run this over every dependency to add it to the dependencyList\n                dependency => {\n                    //make sure if dependency is initialized, then add\n                    list[dependency.name] = initialize(_this, dependency, list);\n                }\n            );\n\n            return initialize(_this, service, list);\n        }\n\n    /**\n         * Access service with dependencies bound\n         *\n         * @param {String} name The Name of the service\n         * @returns {*} Returns Content of the service\n         */\n    function access(name) {\n            const _this = this,\n                accessedService = _this.chev[name];\n\n            //Check if accessed service is registered\n            if (accessedService) {\n                //Call prepare with bound context\n                return prepare(_this, accessedService).fn;\n            }\n        }\n\n    /**\n         * Creates method entry for service\n         *\n         * @private\n         * @param {Object} _this The context\n         * @returns Returns void\n         */\n    function initService(_this) {\n            _this.extend(_service, function(service, bundle) {\n                //Construct service\n                const serviceFn = service.fn;\n\n                service.fn = function() {\n                    //Chevron service function wrapper\n                    return serviceFn.apply(null, bundle.concat(Array.from(arguments)));\n                };\n\n                return service;\n            });\n        }\n\n    /**\n         * Creates method entry for factory\n         *\n         * @private\n         * @param {Object} _this The context\n         * @returns Returns void\n         */\n    function initFactory(_this) {\n            _this.extend(_factory, function(service, bundle) {\n                //Construct factory\n\n                //First value gets ignored by calling new like this, so we need to fill it\n                bundle.unshift(null);\n\n                //Apply into new constructor by accessing bind proto. from: http://stackoverflow.com/questions/1606797/use-of-apply-with-new-operator-is-this-possible\n                service.fn = new(Function.prototype.bind.apply(service.fn, bundle));\n\n                return service;\n            });\n        }\n\n    /**\r\n         * Basic Chevron Constructor\r\n         *\r\n         * @constructor\r\n         * @param {String} id To identify the instance\r\n         * @returns {Object} Returns Chevron instance\r\n         */\r\n        let Chevron = function(id) {\r\n            const _this = this;\r\n\r\n            //Instance Id\r\n            _this.id = id || \"cv\";\r\n            //Instance container\r\n            _this.chev = {};\r\n\r\n            //Init default types\r\n            initService(_this);\r\n            initFactory(_this);\r\n        };\r\n\r\n        /**\r\n         * Expose Chevron methods\r\n         */\r\n        Chevron.prototype = {\r\n            //Core service/factory method\r\n            provider,\r\n            //Prepare/init services/factory with deps injected\r\n            access,\r\n            //Add new service type\r\n            extend\r\n        };\n\n    /**\r\n         * Store constants\r\n         */\r\n        const _window = window;\r\n        const _document = _window.document;\r\n        const _domNameSpace = \"xn\";\r\n        const _expressionRegex = /{{(.+)}}/g;\n\n    /**\r\n         * Creates querySelector string\r\n         *\r\n         * @private\r\n         * @param {String} data The data id\r\n         * @param {String} val The data value\r\n         * @return {String} Returns Query\r\n         */\r\n    function constructQuery(data, val) {\r\n            if (!val || val === \"*\") {\r\n                return `[${_domNameSpace}-${data}]`;\r\n            } else {\r\n                return `[${_domNameSpace}-${data}='${val}']`;\r\n            }\r\n        }\n\n    /**\r\n         * Query multiple from DOM\r\n         *\r\n         * @private\r\n         * @param {String} data The data id\r\n         * @param {String} val The data value\r\n         * @param {Node} context optional, query context\r\n         * @return {NodeList} Returns NodeList\r\n         */\r\n    function queryDirective(data, val, context) {\r\n            return (context ? context : _document).querySelectorAll(constructQuery(data, val));\r\n        }\n\n    /**\r\n         * Read Data from element\r\n         *\r\n         * @private\r\n         * @param {Node} element The Element to read\r\n         * @param {String} data The data attr to read\r\n         * @return {String} Returns value\r\n         */\r\n    function readDirective(element, data) {\r\n            return element.attributes[`${_domNameSpace}-${data}`].value;\r\n        }\n\n    /**\r\n         * calculates Expression\r\n         *\r\n         * @private\r\n         * @param {Object} ctrl The Controller\r\n         * @param {Object} expression The Expression\r\n         * @return void\r\n         */\r\n    function evaluate(ctrl, expression) {\r\n            const result = ctrl[expression.data];\r\n\r\n            console.log(expression.val, result);\r\n            expression.parent.textContent = expression.parent.textContent.replace(expression.val, result);\r\n            expression.val = result;\r\n\r\n            return result;\r\n        }\n\n    /**\r\n         * Digest & render dom\r\n         *\r\n         * @private\r\n         * @param {Object} ctrl The Controller\r\n         * @return {Node} context The Controller context\r\n         */\r\n    function digest(ctrl) {\r\n            //@TODO implement debounce\r\n\r\n            console.log(\"digest\");\r\n            //Calc expressions\r\n            ctrl.$expressions.forEach(expression => {\r\n                evaluate(ctrl, expression);\r\n            });\r\n        }\n\n    /**\r\n         * Misc Utility functions\r\n         */\r\n\r\n        /**\r\n         * iterate over NoddeList\r\n         *\r\n         * @private\r\n         * @param {NodeList} NodeList The Elements to bind\r\n         * @param {Function} fn The Function to call\r\n         * @return void\r\n         */\r\n        function eachNode(NodeList, fn) {\r\n            const l = NodeList.length;\r\n            let i = 0;\r\n\r\n            while (i < l) {\r\n                fn(NodeList[i], i);\r\n                i++;\r\n            }\r\n        }\n\n    /**\r\n         * Binds event to dom\r\n         *\r\n         * @private\r\n         * @param {NodeList} domList The Elements to bind\r\n         * @param {String} type The Event type\r\n         * @param {Function} fn The Even function\r\n         * @return void\r\n         */\r\n    function bind(domList, type, fn) {\r\n            eachNode(domList, dom => {\r\n                dom.addEventListener(type, eventFn, false);\r\n\r\n                function eventFn(ev) {\r\n                    return fn(ev, dom);\r\n                }\r\n            });\r\n        }\n\n    /**\r\n         * Binds xn-model\r\n         *\r\n         * @private\r\n         * @param {Object} ctrl The Controller\r\n         * @return {Node} context The Controller context\r\n         */\r\n    function bindModel(ctrl, context) {\r\n            const result = [];\r\n            const elements = queryDirective(\"model\", \"*\", context);\r\n\r\n            bind(elements, \"change\", modelEvent);\r\n            bind(elements, \"keydown\", modelEvent);\r\n\r\n            eachNode(elements, (element, index) => {\r\n                result.push({\r\n                    index,\r\n                    element,\r\n                    type: \"model\",\r\n                    value: readDirective(element, \"model\")\r\n                });\r\n            });\r\n\r\n            return result;\r\n\r\n            function modelEvent(ev, dom) {\r\n                const content = dom.value;\r\n                const modelFor = readDirective(dom, \"model\");\r\n\r\n                console.log(\"MODEL:\", modelFor, content);\r\n                ctrl[modelFor] = content;\r\n\r\n                digest(ctrl);\r\n            }\r\n        }\n\n    /**\r\n         * Binds directives to controller\r\n         *\r\n         * @private\r\n         * @param {Object} ctrl The Controller\r\n         * @return {Object} Returns bound Object\r\n         */\r\n    function bindDirectives(ctrl) {\r\n            const context = ctrl.$context;\r\n\r\n            return {\r\n                model: bindModel(ctrl, context)\r\n            };\r\n        }\n\n    /**\r\n         * Query Expressions\r\n         *\r\n         * @private\r\n         * @param {Node} context The Element context\r\n         * @return {NodeList} Returns NodeList\r\n         */\r\n    function queryExpressions(context) {\r\n            const result = [];\r\n            const nodes = getTextNodes(context);\r\n            let match;\r\n\r\n            //Iterate Nodes\r\n            nodes.forEach(node => {\r\n              //Iterate Regex\r\n                while ((match = _expressionRegex.exec(node.textContent)) !== null) {\r\n                    if (match.index === _expressionRegex.lastIndex) {\r\n                        _expressionRegex.lastIndex++;\r\n                    }\r\n\r\n                    result.push({\r\n                        match: match[0],\r\n                        data: match[1],\r\n                        val: match[0],\r\n                        index: match.index,\r\n                        parent : node\r\n                    });\r\n                }\r\n            });\r\n\r\n            return result;\r\n\r\n            //Modified version of http://stackoverflow.com/questions/10730309/find-all-text-nodes-in-html-page\r\n            function getTextNodes(node) {\r\n                let all = [];\r\n                for (node = node.firstChild; node; node = node.nextSibling) {\r\n                    if (node.nodeType === 3 && node.parentNode.nodeName !== \"SCRIPT\") {\r\n                        all.push(node);\r\n                    } else {\r\n                        all = all.concat(getTextNodes(node));\r\n                    }\r\n                }\r\n                return all;\r\n            }\r\n        }\n\n    /**\r\n         * Binds expressions\r\n         *\r\n         * @private\r\n         * @return {Node} context The Controller context\r\n         */\r\n    function bindExpressions$1(context) {\r\n            const elements = queryExpressions(context);\r\n\r\n            return elements;\r\n        }\n\n    /**\r\n         * Binds directives to controller\r\n         *\r\n         * @private\r\n         * @param {Object} ctrl The Controller\r\n         * @return {Object} Returns bound Object\r\n         */\r\n    function bindExpressions(ctrl) {\r\n            const context = ctrl.$context;\r\n            return bindExpressions$1(context);\r\n        }\n\n    /**\r\n         * Creates typeList entry for Controller\r\n         *\r\n         * @private\r\n         * @param {Object} service The service\r\n         * @param {Object} bundle The service deps\r\n         * @return {Function} service\r\n         */\r\n    function controllerFn(service, bundle) {\r\n            //Construct Controller\r\n            //\r\n            //First value gets ignored by calling new like this, so we need to fill it\r\n            bundle.unshift(null);\r\n            //Apply into new constructor by accessing bind proto. from: http://stackoverflow.com/questions/1606797/use-of-apply-with-new-operator-is-this-possible\r\n            const ctrl = service.fn = new(Function.prototype.bind.apply(service.fn, bundle));\r\n\r\n\r\n            //Bind Context\r\n            ctrl.$context = queryDirective(\"controller\", service.name)[0];\r\n            ctrl.$expressions = bindExpressions(ctrl);\r\n            ctrl.$directives = bindDirectives(ctrl);\r\n            //run first digest\r\n            digest(ctrl);\r\n\r\n            console.log(service);\r\n\r\n            return service;\r\n        }\n\n    /**\r\n         * Basic Axon Constructor\r\n         *\r\n         * @constructor\r\n         * @param {String} id To identify the instance\r\n         * @returns {Object} Returns Axon instance\r\n         */\r\n        let Axon = function(id) {\r\n            const _this = this;\r\n\r\n            //Instance Id\r\n            _this.id = id;\r\n            //Instance container\r\n            _this.cv = new Chevron(id + \"Container\");\r\n            //context\r\n            _this.context = queryDirective(\"app\", id)[0];\r\n\r\n            //Init Axon types\r\n            _this.cv.extend(\"controller\", controllerFn);\r\n        };\r\n\r\n        //Bind Chevron methods directly to parent\r\n        const methods = [\"access\", \"extend\", \"provider\", \"service\", \"factory\", \"controller\"];\r\n\r\n        methods.forEach(method => {\r\n            Axon.prototype[method] = function() {\r\n                return this.cv[method].apply(this.cv, Array.from(arguments));\r\n            };\r\n        });\n\n    return Axon;\n\n}());"]}