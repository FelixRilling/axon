{"version":3,"sources":["axon.js"],"names":[],"mappings":";;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"axon.js","sourcesContent":["var Axon = (function () {\n'use strict';\n\n/**\r\n * Adds a new module type to the Chevron instance\r\n * @param {String} type The name of the type\r\n * @param {Function} cf Constructor function to init the module with\r\n * @returns {Object} Chevron instance\r\n */\n\nvar extend = function extend(type, cf) {\n    var _this = this;\n\n    //Add customType method to container\n    _this[type] = function (name, deps, fn) {\n        return _this.provider(type, //static\n        cf, //static\n        name, //dynamic\n        deps, //dynamic\n        fn //dynamic\n        );\n    };\n\n    return _this;\n};\n\n/**\r\n * Collects dependencies and initializes module\r\n * @private\r\n * @param {Object} _module The module to check\r\n * @param {Object} list The list of dependencies\r\n * @param {Function} cf The Constructor function\r\n * @returns {Object} Initialized _module\r\n */\n\nvar constructModule = function constructModule(_module, list, constructorFunction) {\n    var dependencies = [];\n    var result = void 0;\n\n    //Collect an ordered Array of dependencies\n    _module.deps.forEach(function (item) {\n        var dependency = list[item];\n\n        //If the dependency name is found in the list of deps, add it\n        if (dependency) {\n            dependencies.push(dependency.fn);\n        }\n    });\n\n    //Call Constructor fn with _module/deps\n    result = constructorFunction(_module, dependencies);\n    result.rdy = true;\n\n    return result;\n};\n\n/**\r\n * Loops trough dependencies, recurse if new dependencies has dependencies itself; then execute fn.\r\n * @private\r\n * @param {Object} chev The chevron container\r\n * @param {Array} _module The module to recurse\r\n * @param {Function} fn The function run over each dependency\r\n */\n\nvar recurseDependencies = function recurseDependencies(chev, _module, fn) {\n    _module.deps.forEach(function (name) {\n        var dependency = chev.get(name);\n\n        if (dependency) {\n            //recurse over sub-deps\n            recurseDependencies(chev, dependency, fn);\n            //run fn\n            fn(dependency);\n        } else {\n            //if the dependency is not found, throw error with name\n            throw new Error(_module.name + \" is missing dep '\" + name + \"'\");\n        }\n    });\n};\n\n/**\r\n * Inits module and all dependencies\n * @private\r\n * @param {Object} chev The chevron container\r\n * @param {Object} _module The module to prepare\r\n * @param {Function} cf The constructor function\r\n * @returns {Object} Initialized module\r\n */\nvar initialize = function initialize(chev, _module, constructorFunction) {\n    var list = {};\n\n    //Recurse trough _module deps\n    recurseDependencies(chev, _module,\n    //run this over every dependency to add it to the dependencyList\n    function (dependency) {\n        //make sure if dependency is initialized, then add\n        list[dependency.name] = dependency.rdy ? dependency : dependency.init();\n    });\n\n    return constructModule(_module, list, constructorFunction);\n};\n\n/**\r\n * Adds a new module to the container\r\n * @param {String} type The type of the module. ex: \"factory\"\r\n * @param {Function} cf The constructor function of the module\r\n * @param {String} name The name to register the module under. ex: \"myFactory\"\r\n * @param {Array} deps Array of dependenciy names\r\n * @param {Function} fn Content of the module\r\n * @returns {Object} Chevron instance\r\n */\nvar provider = function provider(type, constructorFunction, name, deps, fn) {\n    var _this = this;\n    var entry = {\n        type: type, //Type of the module\n        name: name, //Name of the module\n        deps: deps, //Array of dependencies\n        fn: fn, //Module content function\n        rdy: false, //If the module is ready to access\n        init: function init() {\n            return initialize(_this.chev, entry, constructorFunction); //init the module\n        }\n    };\n\n    //Saves entry to chev container\n    _this.chev.set(name, entry);\n\n    return _this;\n};\n\n/**\r\n * Access module with dependencies bound\r\n * @param {String} name The name of the module to access\r\n * @returns {Mixed} Initialized Object content\r\n */\n\nvar access = function access(name) {\n  return this.chev.get(name).init().fn;\n};\n\n/**\r\n * Constructor function for the service type\r\n * @private\r\n * @param {Object} _module The module object\n * @param {Array} dependencies Array of dependency contents\r\n * @returns {Mixed} Initialized _module\n */\n\nvar service = function service(_module, dependencies) {\n    //Dereference fn to avoid unwanted recursion\n    var serviceFn = _module.fn;\n\n    _module.fn = function () {\n        //Chevron service function wrapper\n        //return function with args injected\n        return serviceFn.apply(null, dependencies.concat(Array.from(arguments)));\n    };\n\n    return _module;\n};\n\n/**\r\n * Constructor function for the factory type\r\n * @private\r\n * @param {Object} _module The module object\n * @param {Array} dependencies Array of dependency contents\r\n * @returns {Mixed} Initialized module\n */\n\nvar factory = function factory(_module, dependencies) {\n    //First value gets ignored by calling 'new' like this, so we need to fill it with something\n    dependencies.unshift(0);\n\n    //Apply into new constructor by binding applying the bind method.\n    //@see: {@link http://stackoverflow.com/questions/1606797/use-of-apply-with-new-operator-is-this-possible }\n    _module.fn = new (Function.prototype.bind.apply(_module.fn, dependencies))();\n\n    return _module;\n};\n\n/**\r\n * Chevron Constructor\r\n * @constructor\r\n * @returns {Object} Chevron instance\r\n */\nvar Chevron = function Chevron() {\n    var _this = this;\n\n    //Instance container\n    _this.chev = new Map();\n\n    //Init default types\n    _this.extend(\"service\", service);\n    _this.extend(\"factory\", factory);\n};\n\n/**\r\n * Expose Chevron methods\r\n */\nChevron.prototype = {\n    extend: extend, //Creates a new module type\n    provider: provider, //Adds a new custom module to the container\n    access: access //Returns initialized module\n};\n\n/**\n * Store constants\n */\n\nvar _window = window;\nvar _document = _window.document;\nvar _domNameSpace = \"xn\";\nvar _expressionRegex = /{{(.+)}}/g;\n\n/**\n * Creates querySelector string\n *\n * @private\n * @param {String} data The data id\n * @param {String} val The data value\n * @return {String} Returns Query\n */\nvar constructQuery = function (data, val) {\n    if (!val || val === \"*\") {\n        return \"[\" + _domNameSpace + \"-\" + data + \"]\";\n    } else {\n        return \"[\" + _domNameSpace + \"-\" + data + \"='\" + val + \"']\";\n    }\n};\n\n/**\n * Query multiple from DOM\n *\n * @private\n * @param {String} data The data id\n * @param {String} val The data value\n * @param {Node} context optional, query context\n * @return {NodeList} Returns NodeList\n */\nvar queryDirective = function (data, val, context) {\n    return (context ? context : _document).querySelectorAll(constructQuery(data, val));\n};\n\n/**\n * Read Data from element\n *\n * @private\n * @param {Node} element The Element to read\n * @param {String} data The data attr to read\n * @return {String} Returns value\n */\nvar readDirective = function (element, data) {\n    return element.attributes[_domNameSpace + \"-\" + data].value;\n};\n\n/**\n * Misc Utility functions\n */\n\n/**\n * iterate over NoddeList\n *\n * @private\n * @param {NodeList} NodeList The Elements to bind\n * @param {Function} fn The Function to call\n * @returns void\n */\n\nfunction eachNode(NodeList, fn) {\n    var l = NodeList.length;\n    var i = 0;\n\n    while (i < l) {\n        fn(NodeList[i], i);\n        i++;\n    }\n}\n/**\n * Iterate object\n *\n * @private\n * @param {Object} object The Object to iterate\n * @param {Function} fn The Function to run\n * @returns void\n */\nfunction eachObject(object, fn) {\n    var keys = Object.keys(object);\n    var l = keys.length;\n    var i = 0;\n\n    while (i < l) {\n        var currentKey = keys[i];\n\n        fn(object[currentKey], currentKey, i);\n        i++;\n    }\n}\n/**\n * replace string at position\n *\n * @private\n * @param {String} string The String to exec\n * @param {String} find The String to find\n * @param {String} replace The String to replace\n * @param {Number} index The Index to start replacing\n * @returns {String} replacedString\n */\nfunction replaceFrom(string, find, replace, index) {\n    return string.substr(0, index) + string.substr(index).replace(find, replace);\n}\n\nvar text = {\n    onBind: function onBind(ctrl, context) {\n        var result = [];\n        var nodes = getTextNodes(context);\n        var match = void 0;\n\n        //Iterate Nodes\n        nodes.forEach(function (node) {\n            //Iterate Regex\n            while ((match = _expressionRegex.exec(node.textContent)) !== null) {\n                if (match.index === _expressionRegex.lastIndex) {\n                    _expressionRegex.lastIndex++;\n                }\n\n                result.push({\n                    match: match[0],\n                    data: match[1],\n                    val: match[0],\n                    index: match.index,\n                    parent: node\n                });\n            }\n        });\n\n        return result;\n\n        //Modified version of http://stackoverflow.com/questions/10730309/find-all-text-nodes-in-html-page\n        function getTextNodes(node) {\n            var all = [];\n            for (node = node.firstChild; node; node = node.nextSibling) {\n                if (node.nodeType === 3 && node.parentNode.nodeName !== \"SCRIPT\") {\n                    all.push(node);\n                } else {\n                    all = all.concat(getTextNodes(node));\n                }\n            }\n            return all;\n        }\n    },\n    onDigest: function onDigest(ctrl, context, entry) {\n        var result = ctrl[entry.data];\n\n        entry.parent.textContent = replaceFrom(entry.parent.textContent, entry.val, result, entry.index);\n        entry.val = result;\n\n        return result;\n    }\n};\n\nvar expressions = {\n    text: text\n};\n\n/**\n * Digest & render dom\n *\n * @private\n * @param {Object} ctrl The Controller\n * @return {Node} context The Controller context\n */\nvar digest = function (ctrl) {\n    //@TODO implement debounce\n\n    iteratePlugins(directives, ctrl.$directives, function (entry, plugin) {\n        plugin.onDigest(ctrl, ctrl.$context, entry);\n    });\n\n    iteratePlugins(expressions, ctrl.$expressions, function (entry, plugin) {\n        plugin.onDigest(ctrl, ctrl.$context, entry);\n    });\n\n    function iteratePlugins(pluginData, data, fn) {\n        eachObject(pluginData, function (plugin, key) {\n            var active = data[key];\n\n            active.forEach(function (entry) {\n                fn(entry, plugin);\n            });\n        });\n    }\n};\n\n/**\n * Binds event to dom\n *\n * @private\n * @param {NodeList} domList The Elements to bind\n * @param {String} type The Event type\n * @param {Function} fn The Even function\n * @return void\n */\nvar bind = function (domList, type, fn) {\n    eachNode(domList, function (dom) {\n        dom.addEventListener(type, eventFn, false);\n\n        function eventFn(ev) {\n            return fn(ev, dom);\n        }\n    });\n};\n\nvar model = {\n    onBind: function onBind(ctrl, context) {\n        var result = [];\n        var elements = queryDirective(\"model\", \"*\", context);\n\n        bind(elements, \"change\", modelEvent);\n        bind(elements, \"input\", modelEvent);\n\n        eachNode(elements, function (element, index) {\n            result.push({\n                index: index,\n                element: element,\n                type: \"model\",\n                value: readDirective(element, \"model\")\n            });\n        });\n\n        return result;\n\n        function modelEvent(ev, dom) {\n            _window.setTimeout(function () {\n                var content = dom.value;\n                var modelFor = readDirective(dom, \"model\");\n\n                console.log(\"MODEL:\", modelFor, content);\n                ctrl[modelFor] = content;\n\n                digest(ctrl);\n            }, 5);\n        }\n    },\n    onDigest: function onDigest(ctrl, context, entry) {\n        entry.element.value = ctrl[entry.value];\n    }\n};\n\n//import changeImported from \"./change\";\n\nvar directives = {\n    model: model\n};\n\n/**\n * Binds directives to controller\n *\n * @private\n * @param {Object} ctrl The Controller\n * @return {Object} Returns bound Object\n */\nvar bindDirectives = function (ctrl) {\n    var result = {};\n\n    eachObject(directives, function (directive, key, index) {\n        result[key] = directive.onBind(ctrl, ctrl.$context);\n    });\n\n    return result;\n};\n\n/**\n * Binds expressions to controller\n *\n * @private\n * @param {Object} ctrl The Controller\n * @return {Object} Returns bound Object\n */\nvar bindExpressions = function (ctrl) {\n    var result = {};\n\n    eachObject(expressions, function (expressions$$1, key, index) {\n        result[key] = expressions$$1.onBind(ctrl, ctrl.$context);\n    });\n\n    return result;\n};\n\n/**\n * Creates typeList entry for Controller\n *\n * @private\n * @param {Object} service The service\n * @param {Object} bundle The service deps\n * @return {Function} service\n */\nvar controllerFn = function (service, bundle) {\n    //Construct Controller\n    //\n    //First value gets ignored by calling new like this, so we need to fill it\n    bundle.unshift(null);\n    //Apply into new constructor by accessing bind proto. from: http://stackoverflow.com/questions/1606797/use-of-apply-with-new-operator-is-this-possible\n    var ctrl = service.fn = new (Function.prototype.bind.apply(service.fn, bundle))();\n\n    //Bind Context\n    ctrl.$context = queryDirective(\"controller\", service.name)[0];\n    ctrl.$expressions = bindExpressions(ctrl);\n    ctrl.$directives = bindDirectives(ctrl);\n    //run first digest\n    digest(ctrl);\n\n    console.log(service);\n\n    return service;\n};\n\n/**\n * Basic Axon Constructor\n *\n * @constructor\n * @param {String} id To identify the instance\n * @returns {Object} Returns Axon instance\n */\nvar Axon = function Axon(id) {\n    var _this = this;\n\n    //Instance Id\n    _this.id = id;\n    //Instance container\n    _this.cv = new Chevron(id + \"Container\");\n    //context\n    _this.context = queryDirective(\"app\", id)[0];\n\n    //Init Axon types\n    _this.cv.extend(\"controller\", controllerFn);\n};\n\n//Bind Chevron methods directly to parent\nvar methods = [\"access\", \"extend\", \"provider\", \"service\", \"factory\", \"controller\"];\n\nmethods.forEach(function (method) {\n    Axon.prototype[method] = function () {\n        return this.cv[method].apply(this.cv, Array.from(arguments));\n    };\n});\n\nreturn Axon;\n\n}());\n"]}