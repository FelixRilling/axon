{"version":3,"sources":["/axon.js"],"names":[],"mappings":";;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"axon.js","sourcesContent":["var Axon = (function () {\n'use strict';\n\nvar directiveIgnoreBoth = function directiveIgnoreBoth() {\n    return false;\n};\n\nvar DOM_EVENT_TIMEOUT = 20; //event timeout in ms\nvar DOM_EVENT_MODEL = \"input\";\n\nvar DOM_ATTR_PREFIX = \"x-\";\nvar DOM_ATTR_HIDDEN = \"hidden\";\nvar DOM_ATTR_VALUE = \"value\";\nvar DOM_ATTR_TEXT = \"textContent\";\nvar DOM_ATTR_HTML = \"innerHTML\";\n\nvar LIB_STRING_QUOTES = [\"'\", \"\\\"\", \"`\"];\n\nvar retrieveMethod = function retrieveMethod(instance, expression) {\n    var expressionSplit = expression.substr(0, expression.length - 1).split(\"(\");\n    var methodName = expressionSplit[0];\n    var methodArgs = expressionSplit[1].split(\",\").filter(function (item) {\n        return item !== \"\";\n    }).map(function (arg) {\n        return evaluateExpression(instance, arg);\n    });\n    var methodFn = instance.$methods[methodName];\n\n    if (typeof methodFn === \"function\") {\n        return {\n            fn: methodFn,\n            args: methodArgs\n        };\n    } else {\n        throw new Error(\"Missing method '\" + expression + \"'\");\n    }\n};\n\nvar isDefined = function isDefined(val) {\n    return typeof val !== \"undefined\";\n};\n\nvar retrieveProp = function retrieveProp(instance, expression) {\n    var splitExpression = expression.split(\".\");\n    var result = {\n        val: null,\n        ref: null\n    };\n    var container = instance.$data;\n    var prop = void 0;\n\n    splitExpression.forEach(function (propPath, index) {\n        prop = container[propPath];\n\n        if (isDefined(prop)) {\n\n            if (index < splitExpression.length - 1) {\n                container = prop;\n            } else {\n                result.val = prop;\n                result.ref = container;\n            }\n        } else {\n            throw new Error(\"Missing prop '\" + expression + \"'\");\n        }\n    });\n\n    //console.log(expression,result);\n\n    return result;\n};\n\nvar evaluateExpression = function evaluateExpression(instance, expression) {\n\n    if (!isNaN(Number(expression))) {\n        //expression is a Number\n        return Number(expression);\n    } else if (LIB_STRING_QUOTES.includes(expression.substr(0, 1))) {\n        //expression is a String\n        return expression.substr(1, expression.length - 2);\n    } else if (expression.substr(expression.length - 1) === \")\") {\n        //expression is a Method\n        var method = retrieveMethod(instance, expression);\n\n        return method.fn.apply(instance, method.args);\n    } else {\n        //expression is a Property\n        return retrieveProp(instance, expression).val;\n    }\n};\n\nvar directiveIfRender = function directiveIfRender(instance, node, directive) {\n    var propValue = evaluateExpression(instance, directive.val);\n    var result = Boolean(propValue);\n\n    if (result) {\n        node.removeAttribute(DOM_ATTR_HIDDEN);\n    } else {\n        node.setAttribute(DOM_ATTR_HIDDEN, DOM_ATTR_HIDDEN);\n    }\n\n    return result;\n};\n\nvar arrayFrom = function arrayFrom(arr) {\n    return Array.from(arr);\n};\n\nvar debounce = function debounce(fn, wait, immediate) {\n    var timeout = void 0;\n\n    return function () {\n        var context = this;\n        var args = arrayFrom(arguments);\n        var callNow = immediate && !timeout;\n        var later = function later() {\n            timeout = null;\n            if (!immediate) {\n                fn.apply(context, args);\n            }\n        };\n\n        clearTimeout(timeout);\n        timeout = setTimeout(later, wait);\n        if (callNow) {\n            fn.apply(context, args);\n        }\n    };\n};\n\nvar getNodeValueType = function getNodeValueType(node) {\n    if (isDefined(node[DOM_ATTR_VALUE])) {\n        return DOM_ATTR_VALUE;\n    } else if (isDefined(node[DOM_ATTR_TEXT])) {\n        return DOM_ATTR_TEXT;\n    } else {\n        return DOM_ATTR_HTML;\n    }\n};\n\nvar bindEvent = function bindEvent(node, eventType, eventFn, eventArgs, instance) {\n    var debouncedFn = debounce(eventFn, DOM_EVENT_TIMEOUT);\n    var nodeValueType = getNodeValueType(node);\n\n    var eventFnWrapper = function eventFnWrapper(event) {\n        var target = event.target;\n        var args = arrayFrom(eventArgs);\n\n        args.push(target[nodeValueType], target, event);\n\n        return debouncedFn.apply(instance, args);\n    };\n\n    return node.addEventListener(eventType, eventFnWrapper, false);\n};\n\nvar directiveOnInit = function directiveOnInit(instance, node, directive) {\n    var targetMethod = retrieveMethod(instance, directive.val);\n\n    bindEvent(node, directive.opt, targetMethod.fn, targetMethod.args, instance);\n\n    return true;\n};\n\nvar directiveModelInit = function directiveModelInit(instance, node, directive) {\n    var targetProp = retrieveProp(instance, directive.val);\n    var eventFn = function eventFn(currentValue, newValue) {\n        targetProp.ref[directive.val] = newValue;\n\n        setTimeout(function () {\n            instance.$render();\n        }, DOM_EVENT_TIMEOUT);\n    };\n\n    bindEvent(node, DOM_EVENT_MODEL, eventFn, [targetProp.val], instance);\n\n    return true;\n};\n\nvar directiveModelRender = function directiveModelRender(instance, node, directive) {\n    var nodeValueType = getNodeValueType(node);\n    var propValue = retrieveProp(instance, directive.val);\n\n    node[nodeValueType] = propValue.val;\n\n    return true;\n};\n\nvar directiveBindRender = function directiveBindRender(instance, node, directive) {\n    var propValue = evaluateExpression(instance, directive.val);\n\n    node.setAttribute(directive.opt, propValue);\n\n    return true;\n};\n\n/*import {\n    directiveForInit,\n    directiveForRender\n} from \"./modules/directiveFor\";*/\n\nvar directives = {\n    ignore: {\n        init: directiveIgnoreBoth, //Init function\n        render: directiveIgnoreBoth //Render function\n    },\n    if: {\n        render: directiveIfRender\n    },\n    on: {\n        init: directiveOnInit\n    },\n    model: {\n        init: directiveModelInit,\n        render: directiveModelRender\n    },\n    bind: {\n        render: directiveBindRender\n    }\n};\n\nvar execDirectives = function execDirectives(instance, domMap, execMode) {\n    var recurseMap = function recurseMap(mapNode) {\n        var nodeChildren = mapNode.children;\n        var nodeDirectives = mapNode.directives;\n        var result = true;\n\n        //Exec on node\n        if (nodeDirectives.length) {\n            //Only exec if directives on domNode\n            mapNode.directives.forEach(function (directive) {\n                var directiveRef = directives[directive.key];\n\n                if (directiveRef) {\n                    //Only exec if directive exists\n                    var directiveRefFn = directiveRef[execMode];\n\n                    if (directiveRefFn) {\n                        //Only exec if directive has fn for current execMode\n                        var directiveResult = directiveRefFn(instance, mapNode.node, directive);\n\n                        if (!directiveResult) {\n                            //Stop crawling on directive return 'false'\n                            result = false;\n                        }\n                    }\n                }\n            });\n        }\n\n        //Crawl children\n        if (result && nodeChildren.length) {\n            nodeChildren.forEach(function (child) {\n                recurseMap(child);\n            });\n        }\n    };\n\n    recurseMap(domMap);\n};\n\nvar getDirectives = function getDirectives(node) {\n    var attrArr = arrayFrom(node.attributes);\n    var result = [];\n\n    attrArr.forEach(function (attr) {\n        //If is Axon attribute\n        if (attr.name.substr(0, DOM_ATTR_PREFIX.length) === DOM_ATTR_PREFIX) {\n            var splitName = attr.name.replace(DOM_ATTR_PREFIX, \"\").split(\":\");\n\n            result.push({\n                key: splitName[0],\n                opt: splitName[1] || false,\n                val: attr.value\n            });\n        }\n    });\n\n    return result;\n};\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\nvar getDomMap = function getDomMap(entry) {\n    var recurseNodes = function recurseNodes(node) {\n        var nodeDirectives = getDirectives(node);\n        var nodeChildren = node.children;\n\n        if (nodeDirectives.length || nodeChildren.length) {\n            var _ret = function () {\n                var result = {\n                    node: node,\n                    directives: nodeDirectives,\n                    children: []\n                };\n                var childArr = arrayFrom(nodeChildren);\n\n                childArr.forEach(function (childNode) {\n                    var childResult = recurseNodes(childNode);\n\n                    if (isDefined(childResult)) {\n                        result.children.push(childResult);\n                    }\n                });\n\n                return {\n                    v: result\n                };\n            }();\n\n            if ((typeof _ret === \"undefined\" ? \"undefined\" : _typeof(_ret)) === \"object\") return _ret.v;\n        }\n    };\n\n    return recurseNodes(entry);\n};\n\nvar init = function init() {\n  var _this = this;\n\n  _this.$cache = getDomMap(_this.$context);\n  execDirectives(_this, _this.$cache, \"init\");\n  console.log(\"CALLED $init\");\n};\n\nvar render = function render() {\n    var _this = this;\n\n    execDirectives(_this, _this.$cache, \"render\");\n    console.log(\"CALLED $render\");\n};\n\n/**\n * Basic Axon Constructor\n *\n * @constructor\n * @param {String} id To identify the instance\n * @returns {Object} Returns Axon instance\n */\nvar Axon = function Axon(config) {\n    var _this = this;\n\n    _this.$context = document.querySelector(config.context);\n    _this.$data = config.data;\n    _this.$methods = config.methods;\n    _this.$cache = {};\n\n    _this.$init();\n    _this.$render();\n};\n\n/**\n * Expose Axon methods\n */\nAxon.prototype = {\n    $init: init,\n    $render: render,\n    constructor: Axon\n};\n\nreturn Axon;\n\n}());\n"]}