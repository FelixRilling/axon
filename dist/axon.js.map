{"version":3,"sources":["axon.js"],"names":[],"mappings":";;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"axon.js","sourcesContent":["var Axon = (function () {\n'use strict';\n\n/**\r\n * Adds a new module type to the Chevron instance\r\n * @param {String} type The name of the type\r\n * @param {Function} cf Constructor function to init the module with\r\n * @returns {Object} Chevron instance\r\n */\n\nvar extend = function extend(type, cf) {\n    var _this = this;\n\n    //Add customType method to container\n    _this[type] = function (name, deps, fn) {\n        return _this.provider(type, //static\n        cf, //static\n        name, //dynamic\n        deps, //dynamic\n        fn //dynamic\n        );\n    };\n\n    return _this;\n};\n\n/**\r\n * Collects dependencies and initializes module\r\n * @private\r\n * @param {Object} _module The module to check\r\n * @param {Object} list The list of dependencies\r\n * @param {Function} cf The Constructor function\r\n * @returns {Object} Initialized _module\r\n */\n\nvar constructModule = function constructModule(_module, list, constructorFunction) {\n    var dependencies = [];\n    var result = void 0;\n\n    //Collect an ordered Array of dependencies\n    _module.deps.forEach(function (item) {\n        var dependency = list[item];\n\n        //If the dependency name is found in the list of deps, add it\n        if (dependency) {\n            dependencies.push(dependency.fn);\n        }\n    });\n\n    //Call Constructor fn with _module/deps\n    result = constructorFunction(_module, dependencies);\n    result.rdy = true;\n\n    return result;\n};\n\n/**\r\n * Loops trough dependencies, recurse if new dependencies has dependencies itself; then execute fn.\r\n * @private\r\n * @param {Object} chev The chevron container\r\n * @param {Array} _module The module to recurse\r\n * @param {Function} fn The function run over each dependency\r\n */\n\nvar recurseDependencies = function recurseDependencies(chev, _module, fn) {\n    _module.deps.forEach(function (name) {\n        var dependency = chev.get(name);\n\n        if (dependency) {\n            //recurse over sub-deps\n            recurseDependencies(chev, dependency, fn);\n            //run fn\n            fn(dependency);\n        } else {\n            //if the dependency is not found, throw error with name\n            throw new Error(_module.name + \" is missing dep '\" + name + \"'\");\n        }\n    });\n};\n\n/**\r\n * Inits module and all dependencies\n * @private\r\n * @param {Object} chev The chevron container\r\n * @param {Object} _module The module to prepare\r\n * @param {Function} cf The constructor function\r\n * @returns {Object} Initialized module\r\n */\nvar initialize = function initialize(chev, _module, constructorFunction) {\n    var list = {};\n\n    //Recurse trough _module deps\n    recurseDependencies(chev, _module,\n    //run this over every dependency to add it to the dependencyList\n    function (dependency) {\n        //make sure if dependency is initialized, then add\n        list[dependency.name] = dependency.rdy ? dependency : dependency.init();\n    });\n\n    return constructModule(_module, list, constructorFunction);\n};\n\n/**\r\n * Adds a new module to the container\r\n * @param {String} type The type of the module. ex: \"factory\"\r\n * @param {Function} cf The constructor function of the module\r\n * @param {String} name The name to register the module under. ex: \"myFactory\"\r\n * @param {Array} deps Array of dependenciy names\r\n * @param {Function} fn Content of the module\r\n * @returns {Object} Chevron instance\r\n */\nvar provider = function provider(type, constructorFunction, name, deps, fn) {\n    var _this = this;\n    var entry = {\n        type: type, //Type of the module\n        name: name, //Name of the module\n        deps: deps, //Array of dependencies\n        fn: fn, //Module content function\n        rdy: false, //If the module is ready to access\n        init: function init() {\n            return initialize(_this.chev, entry, constructorFunction); //init the module\n        }\n    };\n\n    //Saves entry to chev container\n    _this.chev.set(name, entry);\n\n    return _this;\n};\n\n/**\r\n * Access module with dependencies bound\r\n * @param {String} name The name of the module to access\r\n * @returns {Mixed} Initialized Object content\r\n */\n\nvar access = function access(name) {\n  return this.chev.get(name).init().fn;\n};\n\n/**\r\n * Constructor function for the service type\r\n * @private\r\n * @param {Object} _module The module object\n * @param {Array} dependencies Array of dependency contents\r\n * @returns {Mixed} Initialized _module\n */\n\nvar service = function service(_module, dependencies) {\n    //Dereference fn to avoid unwanted recursion\n    var serviceFn = _module.fn;\n\n    _module.fn = function () {\n        //Chevron service function wrapper\n        //return function with args injected\n        return serviceFn.apply(null, dependencies.concat(Array.from(arguments)));\n    };\n\n    return _module;\n};\n\n/**\r\n * Constructor function for the factory type\r\n * @private\r\n * @param {Object} _module The module object\n * @param {Array} dependencies Array of dependency contents\r\n * @returns {Mixed} Initialized module\n */\n\nvar factory = function factory(_module, dependencies) {\n    //First value gets ignored by calling 'new' like this, so we need to fill it with something\n    dependencies.unshift(0);\n\n    //Apply into new constructor by binding applying the bind method.\n    //@see: {@link http://stackoverflow.com/questions/1606797/use-of-apply-with-new-operator-is-this-possible }\n    _module.fn = new (Function.prototype.bind.apply(_module.fn, dependencies))();\n\n    return _module;\n};\n\n/**\r\n * Store constants\r\n */\n\n\nvar _document = document;\nvar _domNameSpace = \"xn\";\nvar _debounceTimeout = 40;\n//export const _expressionRegex = /{{(.+)}}/g;\n\n/**\r\n * Get directive dom name\r\n * @param  {String} name Directive name\r\n * @return {String}      Dom name\r\n */\nvar getDataQueryDom = function getDataQueryDom(name) {\n    return _domNameSpace + \"-\" + name;\n};\n\n/**\r\n * Get directive dataset name\r\n * @param  {String} name Directive name\r\n * @return {String}      Dataset name\r\n */\n\n/**\r\n * Creates querySelector string\r\n *\r\n * @private\r\n * @param {String} name The data name\r\n * @param {String} val The data value\r\n * @return {String} Returns Query\r\n */\nvar getSelectorQuery = function getSelectorQuery(name, val) {\n    var dataQuery = getDataQueryDom(name);\n\n    if (val) {\n        return \"[\" + dataQuery + \"='\" + val + \"']\";\n    } else {\n        return \"[\" + dataQuery + \"]\";\n    }\n};\n\n/**\n * Queries all nodes in context with the given directive\n * @param  {Node}  context     Context to query\n * @param  {String}  name         Directive name\n * @param  {String|Boolean}  val          Directive value, or false if it should be ignored\n * @param  {Boolean} [multi=true] If more than one element should be queried\n * @return {Node|NodeList}               Query result\n */\nvar queryDirective = function queryDirective(context, name, val) {\n    var multi = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n\n    var query = getSelectorQuery(name, val);\n\n    return multi ? context.querySelectorAll(query) : context.querySelector(query);\n};\n\n/**\n * Misc Utility functions\n */\n\n/**\n * iterate over NodeList\n *\n * @private\n * @param {NodeList} NodeList The Elements to bind\n * @param {Function} fn The Function to call\n * @returns void\n */\n\nfunction eachNode(NodeList, fn) {\n    var l = NodeList.length;\n    var i = 0;\n\n    while (i < l) {\n        fn(NodeList[i], i);\n        i++;\n    }\n}\n/**\n * Iterate object\n *\n * @private\n * @param {Object} object The Object to iterate\n * @param {Function} fn The Function to run\n * @returns void\n */\n/*export function eachObject(object, fn) {\n    const keys = Object.keys(object);\n    const l = keys.length;\n    let i = 0;\n\n    while (i < l) {\n        const currentKey = keys[i];\n\n        fn(object[currentKey], currentKey, i);\n        i++;\n    }\n}*/\n/**\n * replace string at position\n *\n * @private\n * @param {String} string The String to exec\n * @param {String} find The String to find\n * @param {String} replace The String to replace\n * @param {Number} index The Index to start replacing\n * @returns {String} replacedString\n */\n/*export function replaceFrom(string, find, replace, index) {\n    return string.substr(0, index) + string.substr(index).replace(find, replace);\n}*/\n\n/**\r\n * Get value of directive on node\r\n * @param  {Node} node Node to check\r\n * @param  {String} name Directive to check\r\n * @return {String}      Directive value\r\n */\nvar getDirectiveValue = function getDirectiveValue(node, name) {\n    var dataQuery = getDataQueryDom(name);\n\n    return node.attributes[dataQuery].value;\n};\n\nvar debounce = function debounce(fn, wait, immediate) {\n    var timeout = void 0;\n\n    return function () {\n        var context = this;\n        var args = arguments;\n        var later = function later() {\n            timeout = null;\n            if (!immediate) {\n                fn.apply(context, args);\n            }\n        };\n        var callNow = immediate && !timeout;\n\n        clearTimeout(timeout);\n        timeout = setTimeout(later, wait);\n        if (callNow) {\n            fn.apply(context, args);\n        }\n    };\n};\n\nvar bindEvent = function bindEvent(node, eventType, eventFn) {\n    var debouncedFn = debounce(eventFn, _debounceTimeout);\n\n    node.addEventListener(eventType, debouncedFn, false);\n};\n\nvar applyDirectives = function applyDirectives(ctrl) {\n    ctrl.$directives.forEach(function (directive) {\n        directive.forEach(function (directiveInstance) {\n            directiveInstance.instanceOf.onApply(directiveInstance.node, ctrl, directiveInstance.data);\n        });\n    });\n};\n\nvar renderDirectives = function renderDirectives(ctrl) {\n    ctrl.$directives.forEach(function (directive) {\n        directive.forEach(function (directiveInstance) {\n            directiveInstance.instanceOf.onRender(directiveInstance.node, ctrl, directiveInstance.data);\n        });\n    });\n};\n\n// UI -> Ctrl\nvar apply = function apply(ctrl) {\n    var applyFn = debounce(applyDirectives, _debounceTimeout);\n    var renderFn = debounce(renderDirectives, _debounceTimeout);\n\n    console.log(\"C:APPLY\");\n    console.log(ctrl);\n\n    applyFn(ctrl);\n    renderFn(ctrl);\n};\n\n// Ctrl -> UI\nvar render = function render(ctrl) {\n    var renderFn = debounce(renderDirectives, _debounceTimeout);\n    var applyFn = debounce(applyDirectives, _debounceTimeout);\n\n    console.log(\"C:RENDER\");\n    renderFn(ctrl);\n    applyFn(ctrl);\n};\n\nvar directiveModelOnInit = function directiveModelOnInit(node, ctrl, directiveContent) {\n    var modelType = typeof node.value !== \"undefined\" ? \"value\" : \"innerText\";\n    var eventFn = function eventFn(ev) {\n        apply(ctrl);\n    };\n\n    render(ctrl);\n\n    //Bin dependent on nodetype\n    bindEvent(node, \"change\", eventFn);\n    bindEvent(node, \"keydown\", eventFn);\n\n    return {\n        modelType: modelType,\n        modelFor: directiveContent\n    };\n};\n\nvar directiveModelOnRender = function directiveModelOnRender(node, ctrl, data) {\n    console.log(\"D:RENDER\");\n    node[data.modelType] = ctrl[data.modelFor];\n};\n\nvar directiveModelOnApply = function directiveModelOnApply(node, ctrl, data) {\n  console.log(\"D:APPLY\");\n  ctrl[data.modelFor] = node[data.modelType];\n};\n\nvar directiveModel = {\n    name: \"model\",\n    onInit: directiveModelOnInit,\n    onRender: directiveModelOnRender,\n    onApply: directiveModelOnApply\n};\n\nvar directiveEventOnInit = function directiveEventOnInit(node, ctrl, directiveContent) {\n    var delemitEventList = function delemitEventList(str) {\n        return str.split(\",\").map(function (pair) {\n            return pair.trim().split(\":\").map(function (item) {\n                return item.trim();\n            });\n        });\n    };\n    var events = delemitEventList(directiveContent);\n\n    events.forEach(function (eventItem) {\n        var eventFn = function eventFn(ev) {\n            var fn = ctrl[eventItem[1]];\n            console.log(\"C:FIRED\");\n            fn(ev, node);\n\n            //render(ctrl);\n        };\n\n        bindEvent(node, eventItem[0], eventFn);\n    });\n\n    return {\n        events: events\n    };\n};\n\nvar directiveEventOnRender = function directiveEventOnRender(node, ctrl, data) {};\n\nvar directiveEventOnApply = function directiveEventOnApply(node, ctrl, data) {};\n\nvar directiveEvent = {\n    name: \"on\",\n    onInit: directiveEventOnInit,\n    onRender: directiveEventOnRender,\n    onApply: directiveEventOnApply\n};\n\nvar directives = [directiveEvent, directiveModel];\n\n/**\r\n * Binds all directive plugins to the controller\r\n * @param  {Object} ctrl Axon controller\r\n * @return {Array}      Array of directive results\r\n */\nvar bindDirectives = function bindDirectives(ctrl) {\n    var result = [];\n\n    directives.forEach(function (directive) {\n        var directiveResult = [];\n        var directiveNodes = queryDirective(ctrl.$context, directive.name, false, true);\n\n        eachNode(directiveNodes, function (node) {\n            directiveResult.push({\n                node: node,\n                instanceOf: directive,\n                data: directive.onInit(node, ctrl, getDirectiveValue(node, directive.name))\n            });\n        });\n\n        result.push(directiveResult);\n    });\n\n    return result;\n};\n\n/**\r\n * Constructor function for the controller type\r\n * @private\r\n * @param {Object} _module The module object\r\n * @param {Array} dependencies Array of dependency contents\r\n * @returns {Mixed} Initialized module\r\n */\nvar typeController = function typeController(_module, dependencies) {\n    var _this = this;\n    var ctrl = void 0;\n\n    //First value gets ignored by calling 'new' like this, so we need to fill it with something\n    dependencies.unshift(0);\n\n    //Apply into new constructor by binding applying the bind method.\n    //@see: {@link http://stackoverflow.com/questions/1606797/use-of-apply-with-new-operator-is-this-possible }\n    ctrl = new (Function.prototype.bind.apply(_module.fn, dependencies))();\n\n    //Bind Context\n    ctrl.$context = queryDirective(_this.$context, \"controller\", _module.name, false);\n    //ctrl.$expressions = bindExpressions(_module.fn);\n    ctrl.$directives = bindDirectives(ctrl);\n    //run first digest\n    ctrl.$render = function () {\n        render(ctrl);\n    };\n    ctrl.$apply = function () {\n        apply(ctrl);\n    };\n    //ctrl.$render();\n\n\n    _module.fn = ctrl;\n\n    return _module;\n};\n\n//Chevron import\n\n/**\r\n * Basic Axon Constructor\r\n *\r\n * @constructor\r\n * @param {String} id To identify the instance\r\n * @returns {Object} Returns Axon instance\r\n */\nvar Axon = function Axon(id) {\n    var _this = this;\n\n    //Instance Id\n    _this.$id = id;\n    //Instance container\n    _this.chev = new Map();\n    //context\n    _this.$context = queryDirective(_document, \"app\", id, false);\n\n    //Init default types\n    _this.extend(\"service\", service);\n    _this.extend(\"factory\", factory);\n    _this.extend(\"controller\", typeController.bind(_this));\n};\n\n/**\r\n * Expose Axon methods\r\n */\nAxon.prototype = {\n    extend: extend, //Creates a new module type\n    provider: provider, //Adds a new custom module to the container\n    access: access //Returns initialized module\n};\n\nreturn Axon;\n\n}());\n"]}