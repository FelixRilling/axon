{"version":3,"sources":["axon.js"],"names":[],"mappings":";;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"axon.js","sourcesContent":["var Axon = (function () {\n'use strict';\n\nvar _document = document;\n\nvar TYPE_NAME_UNDEFINED = \"undefined\";\nvar TYPE_NAME_FUNCTION = \"function\";\nvar LIB_DEBOUNCE_TIMEOUT = 32; //event timeout in ms\n\nvar DOM_ATTR_PREFIX = \"x-\";\nvar DOM_ATTR_HIDDEN = \"hidden\";\n\nvar crawlNodes = function crawlNodes(entry, fn) {\n    var recurseNodes = function recurseNodes(node, fn) {\n        var result = fn(node);\n\n        if (result && node.childElementCount) {\n            var childArr = Array.from(node.children);\n\n            childArr.forEach(function (childNode) {\n                result = recurseNodes(childNode, fn);\n            });\n        }\n\n        return result;\n    };\n\n    return recurseNodes(entry, fn);\n};\n\nvar eachDirective = function eachDirective(node, namesList) {\n    var names = namesList.map(function (item) {\n        return item.name;\n    });\n    var attrArr = Array.from(node.attributes);\n    var result = true;\n\n    attrArr.forEach(function (attr) {\n        //If is Axon attribute\n        if (attr.name.substr(0, DOM_ATTR_PREFIX.length) === DOM_ATTR_PREFIX) {\n            var splitName = attr.name.replace(DOM_ATTR_PREFIX, \"\").split(\":\");\n            var nameIndex = names.indexOf(splitName[0]);\n\n            //If name is allowed\n            if (nameIndex !== -1) {\n                result = namesList[nameIndex].fn(splitName[0], splitName[1], attr.value);\n            }\n        }\n    });\n\n    return result;\n};\n\nvar debounce = function debounce(fn, wait, immediate) {\n    var timeout = void 0;\n\n    return function () {\n        var context = this;\n        var args = Array.from(arguments);\n        var callNow = immediate && !timeout;\n        var later = function later() {\n            timeout = null;\n            if (!immediate) {\n                fn.apply(context, args);\n            }\n        };\n\n        clearTimeout(timeout);\n        timeout = setTimeout(later, wait);\n        if (callNow) {\n            fn.apply(context, args);\n        }\n    };\n};\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\nvar getNodeValueType = function getNodeValueType(node) {\n    if (_typeof(node.value) !== TYPE_NAME_UNDEFINED) {\n        return \"value\";\n    } else if (_typeof(node.textContent) !== TYPE_NAME_UNDEFINED) {\n        return \"textContent\";\n    } else {\n        return \"innerHTML\";\n    }\n};\n\nvar bindEvent = function bindEvent(node, eventType, eventFn, eventArgs, instance) {\n    var debouncedFn = debounce(eventFn, LIB_DEBOUNCE_TIMEOUT);\n    var nodeValueType = getNodeValueType(node);\n\n    var eventFnWrapper = function eventFnWrapper(event) {\n        var target = event.target;\n        var args = Array.from(eventArgs);\n\n        args.push(target[nodeValueType], target, event);\n\n        return debouncedFn.apply(instance, args);\n    };\n\n    return node.addEventListener(eventType, eventFnWrapper, false);\n};\n\nvar retrieveProp = function retrieveProp(instance, propName) {\n    var castNumber = Number(propName);\n    var stringChars = [\"'\", \"\\\"\", \"`\"];\n\n    if (!isNaN(castNumber)) {\n        //If number\n        return castNumber;\n    } else if (stringChars.includes(propName[0])) {\n        //If String\n        return propName.substr(1, propName.length - 2);\n    } else {\n        var _ret = function () {\n            //If Prop\n            var propPath = propName.split(\".\");\n            var prop = instance.$data;\n\n            propPath.forEach(function (propItem) {\n                prop = prop[propItem];\n            });\n\n            if ((typeof prop === \"undefined\" ? \"undefined\" : _typeof(prop)) === TYPE_NAME_UNDEFINED) {\n                throw new Error(\"prop '\" + propName + \"' not found\");\n            } else {\n                return {\n                    v: prop\n                };\n            }\n        }();\n\n        if ((typeof _ret === \"undefined\" ? \"undefined\" : _typeof(_ret)) === \"object\") return _ret.v;\n    }\n};\n\nvar retrieveMethod = function retrieveMethod(instance, methodString) {\n    var methodStringSplit = methodString.substr(0, methodString.length - 1).split(\"(\");\n    var methodName = methodStringSplit[0];\n    var methodArgs = methodStringSplit[1].split(\",\").filter(function (item) {\n        return item !== \"\";\n    }).map(function (arg) {\n        return retrieveProp(instance, arg);\n    });\n\n    var methodFn = instance.$methods[methodName];\n\n    if ((typeof methodFn === \"undefined\" ? \"undefined\" : _typeof(methodFn)) !== TYPE_NAME_FUNCTION) {\n        throw new Error(\"method '\" + methodName + \"' not found\");\n    } else {\n        return {\n            fn: methodFn,\n            args: methodArgs\n        };\n    }\n};\n\nvar initOn = function initOn(instance, node, eventType, methodName) {\n    var targetMethod = retrieveMethod(instance, methodName);\n\n    bindEvent(node, eventType, targetMethod.fn, targetMethod.args, instance);\n\n    return true;\n};\n\nvar init = function init() {\n    var _this = this;\n\n    //Bind events\n    crawlNodes(_this.$context, function (node) {\n        return eachDirective(node, [{\n            name: \"on\",\n            fn: function fn(name, nameSecondary, value) {\n                return initOn(_this, node, nameSecondary, value);\n            }\n        }]);\n    });\n\n    console.log(\"CALLED $init\");\n};\n\nvar renderIf = function renderIf(instance, node, propName) {\n    var propValue = retrieveProp(instance, propName);\n    var result = Boolean(propValue);\n\n    if (result) {\n        node.removeAttribute(DOM_ATTR_HIDDEN);\n    } else {\n        node.setAttribute(DOM_ATTR_HIDDEN, DOM_ATTR_HIDDEN);\n    }\n\n    return result;\n};\n\nvar renderModel = function renderModel(instance, node, propName) {\n    var nodeValueType = getNodeValueType(node);\n    var propValue = retrieveProp(instance, propName);\n\n    node[nodeValueType] = propValue;\n\n    return true;\n};\n\nvar renderBind = function renderBind(instance, node, bindType, propName) {\n    var propValue = retrieveProp(instance, propName);\n\n    node.setAttribute(bindType, propValue);\n\n    return true;\n};\n\nvar render = function render() {\n    var _this = this;\n\n    //Render DOM\n    crawlNodes(_this.$context, function (node) {\n        //console.log(node);\n        return eachDirective(node, [{\n            name: \"ignore\",\n            fn: function fn() {\n                return false;\n            }\n        }, {\n            name: \"if\",\n            fn: function fn(name, nameSecondary, value) {\n                return renderIf(_this, node, value);\n            }\n        }, {\n            name: \"model\",\n            fn: function fn(name, nameSecondary, value) {\n                return renderModel(_this, node, value);\n            }\n        }, {\n            name: \"bind\",\n            fn: function fn(name, nameSecondary, value) {\n                return renderBind(_this, node, nameSecondary, value);\n            }\n        }]);\n    });\n\n    console.log(\"CALLED $render\");\n};\n\n/**\n * Basic Axon Constructor\n *\n * @constructor\n * @param {String} id To identify the instance\n * @returns {Object} Returns Axon instance\n */\nvar Axon = function Axon(config) {\n    var autoInit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n    var _this = this;\n\n    _this.$context = _document.querySelector(config.context);\n    _this.$data = config.data;\n    _this.$methods = config.methods;\n\n    if (autoInit) {\n        _this.$init();\n        _this.$render();\n    }\n};\n\n/**\n * Expose Axon methods\n */\nAxon.prototype = {\n    $init: init,\n    $render: render,\n    constructor: Axon\n};\n\nreturn Axon;\n\n}());\n"]}