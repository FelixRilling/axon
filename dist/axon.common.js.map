{"version":3,"sources":["es6/axon.common.js"],"names":[],"mappings":"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","file":"axon.common.js","sourcesContent":["'use strict';\n\n/**\r\n     * Store strings to avoid duplicate strings\r\n     */\r\n    const _more = \": \";\r\n    const _error = \"error in \";\r\n    const _factory = \"factory\";\r\n    const _service = \"service\";\r\n    const _isUndefined = \" is undefined\";\n\n/**\n     * Checks if service exist, else add it\n     *\n     * @param {String} type The type of the service (service/factory)\n     * @param {Function} cf The Constructor function of the service\n     * @param {String} name The name to register/id the service\n     * @param {Array} deps List of dependencies\n     * @param {Function} fn Content of the service\n     * @returns {Object} Returns `this`\n     */\nfunction provider (type, cf, name, deps, fn) {\n        const _this = this;\n\n        if (_this.chev[name]) {\n            //throw error if a service with this name already exists\n            throw _this.id + _more + _error + name + \" already exists\";\n        } else {\n            //Add the service to container\n            _this.chev[name] = {\n                type,\n                cf,\n                name,\n                deps,\n                fn,\n                init: false\n            };\n\n            return _this;\n        }\n    }\n\n/**\n     * Adds a new service type\n     *\n     * @param {String} type The name of the type\n     * @param {Function} cf Constructor function to init the service with\n     * @returns {Object} Returns `this`\n     */\nfunction extend (type, cf) {\n        const _this = this;\n\n        //Add customType method to container\n        _this[type] = function (name, deps, fn) {\n            return _this.provider(type, cf, name, deps, fn);\n        };\n\n        return _this;\n    }\n\n/**\n     * Collects dependencies and initializes service\n     *\n     * @private\n     * @param {Object} _this The context\n     * @param {Object} service The service to check\n     * @param {Object} list The list of dependencies\n     * @returns {Object} Returns `service`\n     */\nfunction initialize (_this, service, list) {\n        if (!service.init) {\n            const bundle = [];\r\n\n            //Collect an ordered Array of dependencies\n            service.deps.forEach(item => {\n                const dependency = list[item];\n\n                if (dependency) {\n                    bundle.push(dependency.fn);\n                }\n            });\n\n            //Init service\n            //Call Constructor fn with service/deps\n            service = service.cf(service, bundle);\n            service.init = true;\n        }\n\n        return service;\n    }\n\n/**\n     * Loops trough dependencies, recurse if new dependencies has dependencies itself; then execute fn.\n     *\n     * @private\n     * @param {Object} _this The context\n     * @param {Array} service The dependencyList to iterate\n     * @param {Function} fn The function run over each dependency\n     * @returns void\n     */\n    function recurseDependencies(_this, service, fn) {\n        //loop trough deps\n        service.deps.forEach(name => {\n            const dependency = _this.chev[name];\n\n            if (dependency) {\n                //recurse over sub-deps\n                recurseDependencies(_this, dependency, fn);\n                //run fn\n                fn(dependency);\n            } else {\n                //if not found error with name\n                throw _this.id + _more + _error + service.name + _more + \"dependency \" + name + _isUndefined;\n            }\n        });\n    }\n\n/**\n     * Check if every dependency is available\n     *\n     * @private\n     * @param {Object} _this The context\n     * @param {Object} service The service to prepare\n     * @returns {Object} Initialized service\n     */\nfunction prepare(_this, service) {\n        const list = {};\n\n        //Recurse trough service deps\n        recurseDependencies(\n            _this,\n            service,\n            //run this over every dependency to add it to the dependencyList\n            dependency => {\n                //make sure if dependency is initialized, then add\n                list[dependency.name] = initialize(_this, dependency, list);\n            }\n        );\n\n        return initialize(_this, service, list);\n    }\n\n/**\n     * Access service with dependencies bound\n     *\n     * @param {String} name The Name of the service\n     * @returns {*} Returns Content of the service\n     */\nfunction access(name) {\n        const _this = this,\n            accessedService = _this.chev[name];\n\n        //Check if accessed service is registered\n        if (accessedService) {\n            //Call prepare with bound context\n            return prepare(_this, accessedService).fn;\n        }\n    }\n\n/**\n     * Creates method entry for service\n     *\n     * @private\n     * @param {Object} _this The context\n     * @returns Returns void\n     */\nfunction initService(_this) {\n        _this.extend(_service, function(service, bundle) {\n            //Construct service\n            const serviceFn = service.fn;\n\n            service.fn = function() {\n                //Chevron service function wrapper\n                return serviceFn.apply(null, bundle.concat(Array.from(arguments)));\n            };\n\n            return service;\n        });\n    }\n\n/**\n     * Creates method entry for factory\n     *\n     * @private\n     * @param {Object} _this The context\n     * @returns Returns void\n     */\nfunction initFactory(_this) {\n        _this.extend(_factory, function(service, bundle) {\n            //Construct factory\n\n            //First value gets ignored by calling new like this, so we need to fill it\n            bundle.unshift(null);\n\n            //Apply into new constructor by accessing bind proto. from: http://stackoverflow.com/questions/1606797/use-of-apply-with-new-operator-is-this-possible\n            service.fn = new(Function.prototype.bind.apply(service.fn, bundle));\n\n            return service;\n        });\n    }\n\n/**\r\n     * Basic Chevron Constructor\r\n     *\r\n     * @constructor\r\n     * @param {String} id To identify the instance\r\n     * @returns {Object} Returns Chevron instance\r\n     */\r\n    let Chevron = function(id) {\r\n        const _this = this;\r\n\r\n        //Instance Id\r\n        _this.id = id || \"cv\";\r\n        //Instance container\r\n        _this.chev = {};\r\n\r\n        //Init default types\r\n        initService(_this);\r\n        initFactory(_this);\r\n    };\r\n\r\n    /**\r\n     * Expose Chevron methods\r\n     */\r\n    Chevron.prototype = {\r\n        //Core service/factory method\r\n        provider,\r\n        //Prepare/init services/factory with deps injected\r\n        access,\r\n        //Add new service type\r\n        extend\r\n    };\n\n/**\r\n     * Store contsants\r\n     */\r\n    const _window = window;\r\n    const _document = _window.document;\r\n    const _domNameSpace = \"xn\";\n\n/**\r\n     * Creates querySelector string\r\n     *\r\n     * @private\r\n     * @param {String} data The data id\r\n     * @param {String} val The data value\r\n     * @return {String} Returns Query\r\n     */\r\nfunction constructQuery(data, val) {\r\n        if (!val || val === \"*\") {\r\n            return `[${_domNameSpace}-${data}]`;\r\n        } else {\r\n            return `[${_domNameSpace}-${data}='${val}']`;\r\n        }\r\n    }\n\n/**\r\n     * Query multiple from DOM\r\n     *\r\n     * @private\r\n     * @param {String} data The data id\r\n     * @param {String} val The data value\r\n     * @param {Node} context optional, query context\r\n     * @return {NodeList} Returns NodeList\r\n     */\r\nfunction query(data, val, context) {\r\n        return (context ? context : _document).querySelectorAll(constructQuery(data, val));\r\n    }\n\n/**\r\n     * Read Data from element\r\n     *\r\n     * @private\r\n     * @param {Node} element The Element to read\r\n     * @param {String} data The data attr to read\r\n     * @return {String} Returns value\r\n     */\r\nfunction read(element, data) {\r\n        return element.attributes[`${_domNameSpace}-${data}`].value;\r\n    }\n\n/**\r\n     * Digest & renders dom\r\n     *\r\n     * @private\r\n     * @param {Object} ctrl The Controller\r\n     * @return {Node} context The Controller context\r\n     */\r\nfunction digest() {\r\n\r\n    }\n\n/**\r\n     * Binds event to dom\r\n     *\r\n     * @private\r\n     * @param {NodeList} domList The Elements to bind\r\n     * @param {String} type The Event type\r\n     * @param {Function} fn The Even function\r\n     * @return {Array} Returns Array of events\r\n     */\r\nfunction bind(domList, type, fn) {\r\n        //const result = {};\r\n        let i = 0;\r\n\r\n        [].forEach.call(domList, dom => {\r\n            /*result[i] = */\r\n            dom.addEventListener(type, ev => {\r\n                return fn(ev, dom);\r\n            }, false);\r\n\r\n            i++;\r\n        });\r\n\r\n        return i;\r\n    }\n\n/**\r\n     * Binds xn-model\r\n     *\r\n     * @private\r\n     * @param {Object} ctrl The Controller\r\n     * @return {Node} context The Controller context\r\n     */\r\nfunction bindModel(ctrl, context) {\r\n        const elements = query(\"model\", \"*\", context);\r\n\r\n        bind(elements, \"change\", modelEvent);\r\n        bind(elements, \"keydown\", modelEvent);\r\n\r\n        return elements;\r\n\r\n        function modelEvent(ev, dom) {\r\n            const content = dom.value;\r\n            const modelFor = read(dom, \"model\");\r\n\r\n            console.log(\"MODEL:\", modelFor, content);\r\n            ctrl[modelFor] = content;\r\n\r\n            digest();\r\n        }\r\n    }\n\n/**\r\n     * Binds expressions to controller\r\n     *\r\n     * @private\r\n     * @param {Object} ctrl The Controller\r\n     * @return {Object} Returns bound Object\r\n     */\r\nfunction bindDirectives(ctrl) {\r\n        const context = ctrl.context;\r\n\r\n        return {\r\n            model: bindModel(ctrl, context)\r\n        };\r\n    }\n\n/**\r\n     * Read Data from element\r\n     *\r\n     * @private\r\n     * @param {Node} element The Element to read\r\n     * @param {String} data The data attr to read\r\n     * @return {String} Returns value\r\n     */\r\nfunction queryExpressions(context) {\r\n\r\n    }\n\n/**\r\n     * Binds directives to controller\r\n     *\r\n     * @private\r\n     * @param {Object} ctrl The Controller\r\n     * @return {Object} Returns bound Object\r\n     */\r\nfunction bindExpressions(ctrl) {\r\n        const context = ctrl.context;\r\n\r\n        return {\r\n            expressions: queryExpressions(context)\r\n        };\r\n    }\n\n/**\r\n     * Creates typeList entry for Controller\r\n     *\r\n     * @private\r\n     * @param {Object} _this The context\r\n     * @return void\r\n     */\r\nfunction controllerFn(service, bundle) {\r\n        //Construct Controller\r\n        //\r\n        //First value gets ignored by calling new like this, so we need to fill it\r\n        bundle.unshift(null);\r\n        //Apply into new constructor by accessing bind proto. from: http://stackoverflow.com/questions/1606797/use-of-apply-with-new-operator-is-this-possible\r\n        const ctrl = service.fn = new(Function.prototype.bind.apply(service.fn, bundle));\r\n        //Bind Context\r\n        ctrl.$context = query(\"controller\", service.name)[0];\r\n        ctrl.$directives = bindDirectives(ctrl);\r\n        ctrl.$expressions = bindExpressions(ctrl);\r\n\r\n        return service;\r\n    }\n\n/**\r\n     * Basic Axon Constructor\r\n     *\r\n     * @constructor\r\n     * @param {String} id To identify the instance\r\n     * @returns {Object} Returns Axon instance\r\n     */\r\n    let Axon = function(id) {\r\n        const _this = this;\r\n\r\n        //Instance Id\r\n        _this.id = id;\r\n        //Instance container\r\n        _this.cv = new Chevron(id + \"Container\");\r\n        //context\r\n        _this.context = query(\"app\", id)[0];\r\n\r\n        //Init Axon types\r\n        _this.cv.extend(\"controller\", controllerFn);\r\n    };\r\n\r\n    //Bind Chevron methods directly to parent\r\n    const methods = [\"access\", \"extend\", \"provider\", \"service\", \"factory\", \"controller\"];\r\n\r\n    methods.forEach(method => {\r\n        Axon.prototype[method] = function() {\r\n            return this.cv[method].apply(this.cv, Array.from(arguments));\r\n        };\r\n    });\n\nmodule.exports = Axon;"]}